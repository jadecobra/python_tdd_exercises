.. include:: ../../links.rst

**************************************
how to measure sleep duration
**************************************

In this chapter I take a look at building a program that returns the amount of time slept between a given sleep and wake time.

----

test_duration_w_hours
======================================

red: make it fail
--------------------------------------------------------

* I open a terminal and call :ref:`createPythonTdd.sh` with ``sleep_duration`` as the project name

  .. code-block:: python

    ./createPythonTdd.sh sleep_duration

  .. NOTE::

    If you are using Windows without `Windows Subsystem Linux`_ use :ref:`createPythonTdd.ps1`

    .. code-block:: python

      ./createPythonTdd.ps1 sleep_duration

* I remove ``test_failure`` after making it pass
* I add a failing test to ``test_sleep_duration.py`` to check that when the ``duration`` :ref:`function<functions>` in the ``sleep_duration`` :doc:`module </exceptions/ModuleNotFoundError>` is called with a ``wake_time`` of ``'08:00'`` and a ``sleep_time`` of ``'07:00'``, it should return the difference between the two timestamps which in this case is ``1``

  .. code-block:: python

    import unittest


    class TestSleepDuration(unittest.TestCase):

        def test_duration_w_hours(self):
            self.assertEqual(
                sleep_duration.duration(
                    wake_time='08:00',
                    sleep_time='07:00'
                ),
                1
            )

  the terminal shows a NameError_

  .. code-block:: python

    NameError: name 'sleep_duration' is not defined

green: make it pass
--------------------------------------------------------

* I add the error to the list of exceptions encountered

  .. code-block:: python

    # Exceptions Encountered
    # AssertionError
    # NameError

* then add an `import statement`_ for the missing name

  .. code-block:: python

    import sleep_duration
    import unittest


    class TestSleepDuration(unittest.TestCase):
    ...

  and the terminal shows an :ref:`AttributeError`. I do not have a definition for ``duration`` in ``sleep_duration.py``

  .. code-block:: python

    AttributeError: module 'sleep_duration' has no attribute 'duration'

* I add the error to the list of exceptions encountered

  .. code-block:: python

    # Exceptions Encountered
    # AssertionError
    # NameError
    # AttributeError

* then add a name to ``sleep_duration.py`` ::

    duration

  and the terminal shows a NameError_ since the name is not defined

  .. code-block:: python

    NameError: name 'duration' is not defined

* I make ``duration`` a variable by assigning it to :ref:`None`

  .. code-block:: python

    duration = None

  and the terminal shows a :ref:`TypeError` because :ref:`None` is not callable_

  .. code-block:: python

    TypeError: 'NoneType' object is not callable

* I add the exception to the list of exceptions encountered

  .. code-block:: python

    # Exceptions Encountered
    # AssertionError
    # NameError
    # AttributeError
    # TypeError

* then define ``duration`` as a :ref:`function<functions>` in ``sleep_duration.py`` to make it callable_

  .. code-block:: python

    def duration():
        return None

  the terminal shows a :ref:`TypeError` with a different message about the first keyword argument given in the test

  .. code-block:: python

    TypeError: duration() got an unexpected keyword argument 'wake_time'

* I add the required keyword argument to the definition of ``duration``, setting its default value to :ref:`None`

  .. code-block:: python

    def duration(wake_time=None):
        return None

  the terminal shows a similar :ref:`TypeError` message for the second keyword argument

  .. code-block:: python

    TypeError: duration() got an unexpected keyword argument 'sleep_time'

* I add the second keyword argument to the definition of the ``duration`` :ref:`function<functions>`

  .. code-block:: python

    def duration(wake_time=None, sleep_time=None):
        return None

  and the terminal shows an :ref:`AssertionError`. The ``duration`` :ref:`function<functions>` returns :ref:`None` but the test expects ``1`` as the result when it passes a sleep time of ``'07:00'`` and a wake time of ``'08:00'``

  .. code-block:: python

    AssertionError: None != 1

* I make the return value for the ``duration`` :ref:`function<functions>` to make it match the expectation

  .. code-block:: python

    def duration(wake_time=None, sleep_time=None):
        return 1

  and the test passes. We are green.

refactor: make it better
--------------------------------------------------------

The ``duration`` :ref:`function<functions>` currently returns ``1`` no matter what inputs are given. It has to calculate the difference between ``wake_time`` and ``sleep_time`` to meet the requirements.

I could write a test case for every possible sleep and wake time, or write one test that uses random variables to cover all the timestamps from ``'00:00'`` to ``'23:59'``

* I add an `import statement`_ for the random_ module to ``test_sleep_duration.py``

  .. code-block:: python

    import random
    import sleep_duration
    import unittest

* then add random values for the hours part of the timestamps in ``test_duration_w_hours``

  .. code-block:: python

    class TestSleepDuration(unittest.TestCase):

        def test_duration_w_hours(self):
            wake_hour = random.randint(0, 23)
            sleep_hour = random.randint(0, 23)

            self.assertEqual(
                sleep_duration.duration(
                    wake_time=f'{wake_hour:02}:00',
                    sleep_time=f'{sleep_hour:02}:00'
                ),
                1
            )

  - ``random.randint(0, 23)`` returns a random number from ``0`` up to and including ``23``
  - ``f'{wake_hour:02}:00'`` and ``f'{sleep_hour:02}:00'`` :doc:`interpolate </how_to/pass_values>` the random numbers in the input strings_
  - the ``:02`` in ``{wake_hour:02}`` and ``{sleep_hour:02}`` tell Python to display the numbers as two digits. For example, display ``01`` instead of ``1``

* the terminal still shows the test is passing because the expected value is ``1``. I make the test match the requirement of the difference between ``wake_time`` and ``sleep_time``

  .. code-block:: python

    def test_duration_w_hours(self):
        wake_hour = random.randint(0, 23)
        sleep_hour = random.randint(0, 23)

        self.assertEqual(
            sleep_duration.duration(
                wake_time=f'{wake_hour:02}:00',
                sleep_time=f'{sleep_hour:02}:00'
            ),
            wake_hour-sleep_hour
        )

  the terminal shows an :ref:`AssertionError`

  .. code-block:: python

    AssertionError: 1 != -2

  .. NOTE::

    Your results may be different because the timestamps are random numbers

* I make the ``duration`` :ref:`function<functions>` to return the subtraction of ``sleep_time`` from ``wake_time``

  .. code-block:: python

    def duration(wake_time=None, sleep_time=None):
        return wake_time - sleep_time

  the terminal shows a :ref:`TypeError`. Python does not have an operation defined for subtracting one string_ from another

  .. code-block:: python

    TypeError: unsupported operand type(s) for -: 'str' and 'str'

  I need to find a way to convert the timestamp from a string_ to a number.

test_string_attributes_and_methods
--------------------------------------

The two inputs are currently in this format - ``XX:00``. If I can get the first 2 characters and convert them to a number, I can calculate the difference since Python can do :doc:`arithmetic </how_to/calculator>`.

red: make it fail
--------------------------------------------------------

* I use the dir_ :ref:`function<functions>` to see what :ref:`methods<functions>` and :ref:`attributes<AttributeError>` of strings_ can help me break a string_ apart or get the characters I want from it

  .. code-block:: python

    def test_string_attributes_and_methods(self):
        self.assertEqual(
            dir('00:00'),
            None
        )

    def test_duration_w_hours(self):
    ...

  the terminal shows an :ref:`AssertionError`

  .. code-block:: python

    AssertionError: ['__add__', '__class__', '__contains__', [918 chars]ill'] != None

* I copy and paste the value on the left side of the comparison to replace :ref:`None` in the test

  .. code-block:: python

    def test_string_attributes_and_methods(self):
        self.assertEqual(
            dir('00:00'),
            ['__add__', '__class__', '__contains__', [918 chars]ill']
        )

  the terminal shows a SyntaxError_

  .. code-block:: python

    E       ['__add__', '__class__', '__contains__', [918 chars]ill']
    E                                                              ^
    E   SyntaxError: unterminated string literal (detected at line 11)

  which I add to the list of exceptions encountered

  .. code-block:: python

    # Exceptions Encountered
    # AssertionError
    # NameError
    # AttributeError
    # TypeError
    # SyntaxError

* I add an opening quote, there is a closing quote with no open quote

  .. code-block:: python

    def test_string_attributes_and_methods(self):
        self.assertEqual(
            dir('00:00'),
            ['__add__', '__class__', '__contains__', '[918 chars]ill']
        )

  and the terminal shows an :ref:`AssertionError` with a different message and a suggestion

  .. code-block:: python

    Diff is 1284 characters long. Set self.maxDiff to None to see it.

* I add the suggestion

  .. code-block:: python

    def test_string_attributes_and_methods(self):
        self.maxDiff = None
        self.assertEqual(
            dir('00:00'),
            ['__add__', '__class__', '__contains__', '[918 chars]ill']
        )

  - the terminal shows a list of :ref:`methods<functions>` and :ref:`attributes<AttributeError>` of a string_
  - `unittest.TestCase.maxDiff`_ sets a limit on the number of characters the terminal shows for a difference between two objects. There is no limit when it is set to :ref:`None`

* I copy and paste the values from the terminal into the test and remove extra characters

  .. NOTE::

    Some attributes may be missing because of your Python version

  .. code-block:: python

    def test_string_attributes_and_methods(self):
        self.maxDiff = None
        self.assertEqual(
            dir('00:00'),
            [
                '__add__',
                '__class__',
                '__contains__',
                '__delattr__',
                '__dir__',
                '__doc__',
                '__eq__',
                '__format__',
                '__ge__',
                '__getattribute__',
                '__getitem__',
                '__getnewargs__',
                '__getstate__',
                '__gt__',
                '__hash__',
                '__init__',
                '__init_subclass__',
                '__iter__',
                '__le__',
                '__len__',
                '__lt__',
                '__mod__',
                '__mul__',
                '__ne__',
                '__new__',
                '__reduce__',
                '__reduce_ex__',
                '__repr__',
                '__rmod__',
                '__rmul__',
                '__setattr__',
                '__sizeof__',
                '__str__',
                '__subclasshook__',
                'capitalize',
                'casefold',
                'center',
                'count',
                'encode',
                'endswith',
                'expandtabs',
                'find',
                'format',
                'format_map',
                'index',
                'isalnum',
                'isalpha',
                'isascii',
                'isdecimal',
                'isdigit',
                'isidentifier',
                'islower',
                'isnumeric',
                'isprintable',
                'isspace',
                'istitle',
                'isupper',
                'join',
                'ljust',
                'lower',
                'lstrip',
                'maketrans',
                'partition',
                'removeprefix',
                'removesuffix',
                'replace',
                'rfind',
                'rindex',
                'rjust',
                'rpartition',
                'rsplit',
                'rstrip',
                'split',
                'splitlines',
                'startswith',
                'strip',
                'swapcase',
                'title',
                'translate',
                'upper',
                'zfill'
            ]
        )

* the test passes and the terminal shows the :ref:`TypeError` from earlier because Python still does not support subtracting one string_ from another

  .. code-block:: python

    TypeError: unsupported operand type(s) for -: 'str' and 'str'

  I need a way to convert a string_ to a number

* I want to try one of the :ref:`methods<functions>` listed in ``test_string_attributes_and_methods`` to see if it will get me closer to a solution but the names in the list do not give me enough information since I do not know what they do, so I use the `help system`_ to check the `python documentation on strings`_ for extra details

  .. code-block:: python

    def test_duration_w_hours(self):
        help(str)
    ...

  the terminal shows documentation for the string_ module and I read through the descriptions for each :ref:`method<functions>` until I see one that looks like a solution to my problem

  .. code-block:: python

    ...
    |
    |  split(self, /, sep=None, maxsplit=-1)
    |      Return a list of the substrings in the string,
    |      using sep as the separator string.
    |
    |        sep
    |          The separator used to split the string.
    |
    ...

  the `str.split`_ :ref:`method<functions>` looks like a good solution since it splits up a word on a given separator

test_string_splitting
---------------------------------

red: make it fail
--------------------------------------------------------

* I remove ``help(str)`` and add a failing test for the `str.split`_ :ref:`method<functions>` to help me understand it

  .. code-block:: python

    def test_string_splitting(self):
        self.assertEqual(
            '01:23'.split(),
            None
        )

    def test_duration_w_hours(self):
    ...

  the terminal shows an :ref:`AssertionError` and I see that `str.split`_ returns a :doc:`list </data_structures/lists/lists>` when called

  .. code-block:: python

    AssertionError: ['01:23'] != None

green: make it pass
--------------------------------------------------------

* I make the expectation to make the test pass

  .. code-block:: python

    def test_string_splitting(self):
        self.assertEqual(
            '01:23'.split(),
            ['01:23']
        )

  and the terminal shows the :ref:`TypeError` that took me down this path

  .. code-block:: python

    TypeError: unsupported operand type(s) for -: 'str' and 'str'

refactor: make it better
--------------------------------------------------------

* I want to `str.split`_ the string_ on a ``separator`` so I get the separate parts, something like ``['01', '23']`` with ``:`` as the separator. I make the expectation of the test to match this idea

  .. code-block:: python

    def test_string_splitting(self):
        self.assertEqual(
            '01:23'.split(),
            ['01', '23']
        )

  and the terminal shows an :ref:`AssertionError`, the use of the `str.split`_ :ref:`method<functions>` has not given me what I want yet

  .. code-block:: python

    AssertionError: Lists differ: ['01:23'] != ['01', '23']

* Looking back at the documentation, I see that `str.split`_ takes in ``sep=None, maxsplit=-1`` as inputs and ``sep`` is the separator. I pass in ``:`` to the `str.split`_ :ref:`method<functions>` as the separator

  .. code-block:: python

    def test_string_splitting(self):
        self.assertEqual(
            '01:23'.split(':'),
            ['01', '23']
        )

  and the test passes. I now know how to get the first parts of ``wake_time`` and ``sleep_time``

* I make the ``duration`` :ref:`function<functions>` in ``sleep_duration.py`` to use the `str.split`_ :ref:`method<functions>`

  .. code-block:: python

    def duration(wake_time=None, sleep_time=None):
        return (
            wake_time.split(':')
          - sleep_time.split(':')
        )

  the terminal shows a :ref:`TypeError`, this time for trying to subtract one :doc:`list </data_structures/lists/lists>` from another

  .. code-block:: python

    TypeError: unsupported operand type(s) for -: 'list' and 'list'

red: make it fail
--------------------------------------------------------

* I only need the first part of the list and can get the specific item by using its index. Python uses `zero-based indexing`_ so the first item is at index ``0`` and the second item is at index ``1``. See :doc:`/data_structures/lists/lists` for more. I add tests for getting specific parts of the :doc:`list </data_structures/lists/lists>` created from splitting a string_ to ``test_string_splitting``

  .. code-block:: python

    def test_string_splitting(self):
        self.assertEqual(
            '01:23'.split(':'),
            ['01', '23']
        )
        self.assertEqual(
            '12:34'.split(':')[0],
            0
        )
        self.assertEqual(
            '12:34'.split(':')[1],
            0
        )

    def test_duration_w_hours(self):
    ...

  the terminal shows an :ref:`AssertionError` because the first item (index 0) from splitting ``'12:34'`` on the separator ``':'`` is ``'12'``

  .. code-block:: python

    AssertionError: '12' != 0

  this is closer to what I want

green: make it pass
--------------------------------------------------------

* I make the expected value in the test to match the value in the terminal

  .. code-block:: python

    self.assertEqual(
        '12:34'.split(':')[0],
        '12'
    )

  the terminal shows another :ref:`AssertionError`

  .. code-block:: python

    AssertionError: '34' != 0

  this shows that the second item (index 1) from splitting ``'12:34'`` on the separator ``':'`` is ``'34'``
* I make the expected value in the same way

  .. code-block:: python

    self.assertEqual(
        '12:34'.split(':')[1],
        '34'
    )

  the tests pass, bringing me back to the unsolved :ref:`TypeError`

* using what I have learned, I make the ``duration`` :ref:`function<functions>` return the subtraction of the first parts of splitting ``wake_time`` and ``sleep_time`` on the separator ``':'``

  .. code-block:: python

    def duration(wake_time=None, sleep_time=None):
        return (
            wake_time.split(':')[0]
          - sleep_time.split(':')[0]
        )

  the terminal shows a :ref:`TypeError` for an unsupported operation of trying to subtract one string_ from another. I know from ``test_string_splitting`` that the strings being subtracted are the values to the left of the separator ``':'``, not the entire values of ``wake_time`` and ``sleep_time``. For example, if the given ``wake_time`` is ``'02:00'`` and the given ``sleep_time`` is ``'01:00'``, the program tries to subtract ``'01'`` from ``'02'`` which is different from trying to subtract ``1`` from ``2``, ``'01'`` is a string_ and ``1`` is a number

test_converting_string_to_integer
------------------------------------

The next task is to convert the string_ to a number so I can do the subtraction

red: make it fail
--------------------------------------------------------

* I disable the current failing test by using the `unittest.skip decorator`_

  .. code-block:: python

    @unittest.skip
    def test_duration_w_hours(self):
    ...

* then add a new failing test to see if I can use the int_ constructor to convert a string_ to a number

  .. code-block:: python

    def test_converting_string_to_integer(self):
        self.assertEqual(int('12'), 0)
        self.assertEqual(int('01'), 0)

    @unittest.skip
    def test_duration_w_hours(self):
    ...

  the terminal shows an :ref:`AssertionError` since ``12 != 0``

  .. code-block:: python

    AssertionError: 12 != 0

green: make it pass
--------------------------------------------------------

* I make the test match the expectation

  .. code-block:: python

    def test_converting_string_to_integer(self):
        self.assertEqual(int('12'), 12)

  and get an :ref:`AssertionError` for the next line

  .. code-block:: python

    AssertionError: 1 != 0

* I make the test match the expectation and we are green again

  .. code-block:: python

    def test_converting_string_to_integer(self):
        self.assertEqual(int('12'), 12)
        self.assertEqual(int('01'), 1)

I have another tool to help solve the problem. I can

- split a string_ on a separator
- index a :doc:`list </data_structures/lists/lists>`
- convert a string_ to a number

* I remove ``@unittest.skip`` from ``test_duration_w_hours`` to show the :ref:`TypeError` I have been trying to solve
* I add the conversion using the int_ constructor to the ``duration`` :ref:`function<functions>` to see if it makes the test pass

  .. code-block:: python

    def duration(wake_time=None, sleep_time=None):
        return (
            int(wake_time.split(':')[0])
          - int(sleep_time.split(':')[0])
        )

  YES! I am green! The ``duration`` function can calculate the sleep duration given any random ``sleep`` and ``wake`` hours. What a beautiful life!

* I can rewrite the solution I have in a way that tries to explain what is happening to someone who does not know how to :doc:`index a list </data_structures/lists/lists>`, use int_ or `str.split`_

  .. code-block:: python

    def duration(wake_time=None, sleep_time=None):
        wake_time_split = wake_time.split(':')
        wake_time_hour = wake_time_split[0]
        wake_time_hour_integer = int(wake_time_hour)

        return (
        # int(wake_time.split(':')[0])
            wake_time_hour_integer
          - int(sleep_time.split(':')[0])
        )

  the terminal shows all tests are still passing

* I try the same thing for ``sleep_time``

  .. code-block:: python

    def duration(wake_time=None, sleep_time=None):
        wake_time_split = wake_time.split(':')
        wake_time_hour = wake_time_split[0]
        wake_time_hour_integer = int(wake_time_hour)

        sleep_time_split = sleep_time.split(':')
        sleep_time_hour = sleep_time_split[0]
        sleep_time_hour_integer = int(sleep_time_hour)

        return (
            wake_time_hour_integer
        # - int(sleep_time.split(':')[0])
          - sleep_time_hour_integer
        )

* The ``duration`` :ref:`function<functions>` does the following for each given timestamp

  - splits the timestamp string_ on the separator ``':'``
  - gets the first item from the split
  - converts the first item from the split to an integer

  I can make these steps a separate function and call it for ``wake_time`` and ``sleep_time``

  .. code-block:: python

    def process(timestamp):
        timestamp_split = timestamp.split(':')
        timestamp_hour = timestamp_split[0]
        timestamp_hour_integer = int(timestamp_hour)
        return timestamp_hour_integer

    def duration(wake_time=None, sleep_time=None):
        return (
            process(wake_time)
          - process(sleep_time)
        )
        wake_time_split = wake_time.split(':')
        wake_time_hour = wake_time_split[0]
        wake_time_hour_integer = int(wake_time_hour)

        sleep_time_split = sleep_time.split(':')
        sleep_time_hour = sleep_time_split[0]
        sleep_time_hour_integer = int(sleep_time_hour)

        return (
            wake_time_hour_integer
          - sleep_time_hour_integer
        )

  all tests are still green

* I remove the parts of ``duration`` that I no longer need and rename ``process`` to something more descriptive like ``get_hour``

  .. code-block:: python

    def get_hour(timestamp):
        timestamp_split = timestamp.split(':')
        timestamp_hour = timestamp_split[0]
        timestamp_hour_integer = int(timestamp_hour)
        return timestamp_hour_integer

    def duration(wake_time=None, sleep_time=None):
        return (
            get_hour(wake_time)
          - get_hour(sleep_time)
        )

  all tests are still passing. I have not broken anything, yet

* I can make ``get_hour`` use the same variable name instead of a new name for each step in the process

  .. code-block:: python

    def get_hour(value):
        value = value.split(':')
        value = value[0]
        value = int(value)
        return value

  the terminal still shows passing tests

* I can also change ``get_hour`` to use one line, though it will no longer be as explicit as above

  .. code-block:: python

    def get_hour(timestamp):
        return int(timestamp.split(':')[0])

  the terminal still shows passing tests

You can try any ideas you want until you understand what has been written so far since all the tests are green. Time for a nap.

----

test_duration_w_hours_and_minutes
===================================

For the ``duration`` :ref:`function<functions>` to meet the requirements, it has to accept timestamps with hours and minutes but it currently returns the right duration when given sleep time and wake wake time hours, without taking minutes into account in the calculation.

red: make it fail
--------------------------------------------------------

I add a failing test in ``test_sleep_duration.py`` that takes minutes into account

.. code-block:: python

  def test_duration_w_hours_and_minutes(self):
      wake_hour = random.randint(0, 23)
      sleep_hour = random.randint(0, 23)
      wake_minutes = random.randint(0, 59)
      sleep_minutes = random.randint(0, 59)

      difference_hours = wake_hour - sleep_hour
      difference_minutes = wake_minutes - sleep_minutes

      self.assertEqual(
          sleep_duration.duration(
              wake_time=f'{wake_hour:02}:{wake_minutes:02}',
              sleep_time=f'{sleep_hour:02}:{sleep_minutes:02}'
          ),
          f'{difference_hours:02}:{difference_minutes:02}'
      )

the terminal shows an :ref:`AssertionError` that looks like this

.. code-block:: python

  AssertionError: 4 != '4:-20'

.. NOTE::

  Your results may be different because the timestamps are random numbers

the expected duration is now a string_ that contains the subtraction of the sleep hour from the wake hour, and the subtraction of the sleep minutes from the wake minutes, separated by ``:``. For example, when given a ``wake_time`` of ``'08:30'`` and a ``sleep_time`` of ``'07:11'``, the duration should be ``'01:19'``

green: make it pass
--------------------------------------------------------

* I make the output of the ``duration`` :ref:`function<functions>` to match the format of the expected value in the test

  .. code-block:: python

    def duration(wake_time=None, sleep_time=None):
        difference_hours = (
            get_hour(wake_time)
          - get_hour(sleep_time)
        )
        difference_minutes = (
            get_hour(wake_time)
          - get_hour(sleep_time)
        )
        return f'{difference_hours}:{difference_minutes}'

  and the terminal shows an :ref:`AssertionError` because changing the format causes an error in ``test_duration_w_hours`` which still expects a number instead of a string_

  .. code-block:: python

    AssertionError: '-4:-4' != -4

  .. NOTE::

    Your results may be different because the timestamps are random numbers

* I make ``test_duration_w_hours`` to use the new format

  .. code-block:: python

    def test_duration_w_hours(self):
        wake_hour = random.randint(0, 23)
        sleep_hour = random.randint(0, 23)

        self.assertEqual(
            sleep_duration.duration(
                wake_time=f'{wake_hour:02}:00',
                sleep_time=f'{sleep_hour:02}:00'
            ),
            f'{wake_hour-sleep_hour}:00'
        )

  the terminal shows an :ref:`AssertionError` that looks like this

  .. code-block:: python

    AssertionError: '17:17' != '17:00'

  the ``duration`` :ref:`function<functions>` currently uses ``get_hour`` for hours and minutes. I need to create a function to use in the calculation for the minutes

* I use the ``get_hour`` function as a reference to create a similar function which gets the minutes from a given timestamp

  .. code-block:: python

    def get_hour(timestamp):
        return int(timestamp.split(':')[0])

    def get_minutes(timestamp):
        return int(timestamp.split(':')[1])

  the terminal still shows an :ref:`AssertionError`

* I make ``duration`` to use ``get_minutes`` in the calculation for ``difference_minutes``

  .. code-block:: python

    def duration(wake_time=None, sleep_time=None):
        difference_hours = (
            get_hour(wake_time)
          - get_hour(sleep_time)
        )
        difference_minutes = (
            get_minutes(wake_time)
          - get_minutes(sleep_time)
        )
        return f'{difference_hours}:{difference_minutes}'

  and ``test_duration_w_hours_and_minutes`` passes leaving an :ref:`AssertionError` for ``test_duration_w_hours`` that looks like this

  .. code-block:: python

    AssertionError: '-8:0' != '-8:00'

* I make ``duration`` display two digits for hours and minutes in the result

  .. code-block:: python

    def duration(wake_time=None, sleep_time=None):
        difference_hours = (
            get_hour(wake_time)
          - get_hour(sleep_time)
        )
        difference_minutes = (
            get_minutes(wake_time)
          - get_minutes(sleep_time)
        )
        return f'{difference_hours:02}:{difference_minutes:02}'

  and update ``test_duration_w_hours`` to do the same thing for the hours

  .. code-block:: python

    def test_duration_w_hours(self):
        wake_hour = random.randint(0, 23)
        sleep_hour = random.randint(0, 23)

        difference_hours = wake_hour - sleep_hour

        self.assertEqual(
            sleep_duration.duration(
                wake_time=f'{wake_hour:02}:00',
                sleep_time=f'{sleep_hour:02}:00'
            ),
            f'{difference_hours:02}:00'
        )

refactor: make it better
--------------------------------------------------------

``test_duration_w_hours_and_minutes`` uses a random number from ``0`` up to and including ``23`` for hours, and a random number from ``0`` up to and including ``59`` for minutes. This means it covers all timestamps from ``00:00`` up to and including ``23:59``, which is all the hours and minutes in a day. I remove ``test_duration_w_hours`` since the timestamps it tests are already included in ``test_duration_w_hours_and_minutes``

test_duration_calculation
==========================

The ``duration`` :ref:`function<functions>` currently returns a subtraction of hours and a subtraction of minutes which is not correct for calculating the difference between two timestamps.

red: make it fail
---------------------------

* If the function is given a ``wake_time`` of ``'03:30'`` and a ``sleep_time`` of ``'02:59'``, it should return ``'00:31'`` as the difference between the timestamps. I add a test for it

  .. code-block:: python

    def test_duration_calculation(self):
        self.assertEqual(
            sleep_duration.duration(
                wake_time='03:30',
                sleep_time='02:59'
            ),
            '00:31'
        )

  the terminal shows an :ref:`AssertionError`

  .. code-block:: python

    AssertionError: '01:-29' != '00:31'

  the ``duration`` :ref:`function<functions>` returns ``'01:-29'`` which is not a real duration

green: make it pass
--------------------------------------------------------

* I rename ``duration`` to keep a copy of my current working solution

  .. code-block:: python

    def duration_a(wake_time=None, sleep_time=None):
        difference_hours = (
            get_hour(wake_time)
          - get_hour(sleep_time)
        )
        difference_minutes = (
            get_minutes(wake_time)
          - get_minutes(sleep_time)
        )
        return f'{difference_hours:02}:{difference_minutes:02}'

* I add a new ``duration`` :ref:`function<functions>` with the following steps to calculate a real difference between two timestamps

  - convert each timestamp to its total minutes by multiplying the hour by 60 and adding the minutes
  - subtract total ``sleep_time`` minutes from total ``wake_time`` minutes
  - return the difference between total ``wake_time`` and ``sleep_time`` as hours and minutes

    * get the hours by using `floor (integer) division`_ to get the whole number value of dividing the difference by 60
    * get the minutes by using the modulo_ operator to get the remainder from dividing the difference by 60

  .. code-block:: python

    def duration(wake_time=None, sleep_time=None):
        wake_time_minutes = (
            (get_hour(wake_time) * 60)
          + get_minutes(wake_time)
        )
        sleep_time_minutes = (
            (get_hour(sleep_time) * 60)
          + get_minutes(sleep_time)
        )
        difference = wake_time_minutes - sleep_time_minutes
        difference_hours = difference // 60
        difference_minutes = difference % 60

        return f'{difference_hours:02}:{difference_minutes:02}'

  since ``test_duration_w_hours_and_minutes`` uses the wrong calculation, the terminal will show random successes and randomly show an :ref:`AssertionError` that looks like this

  .. code-block:: python

    AssertionError: '10:53' != '11:-7'

* I add the correct calculation to ``test_duration_w_hours_and_minutes``

  .. code-block:: python

    def test_duration_w_hours_and_minutes(self):
        wake_hour = random.randint(0, 23)
        sleep_hour = random.randint(0, 23)
        wake_minutes = random.randint(0, 59)
        sleep_minutes = random.randint(0, 59)

        wake_time_minutes = (wake_hour * 60) + wake_minutes
        sleep_time_minutes = (sleep_hour * 60) + sleep_minutes
        difference = wake_time_minutes - sleep_time_minutes
        difference_hours = difference // 60
        difference_minutes = difference % 60

        self.assertEqual(
            sleep_duration.duration(
                wake_time=f'{wake_hour:02}:{wake_minutes:02}',
                sleep_time=f'{sleep_hour:02}:{sleep_minutes:02}'
            ),
            f'{difference_hours:02}:{difference_minutes:02}'
        )

  I have passing tests again

test_floor_aka_integer_division
=================================

The ``//`` operator returns a whole number that tells how many times the denominator can be multiplied to get a whole number that is equal to or less than the numerator

red: make it fail
--------------------

I add a test for it

.. code-block:: python

  def test_floor_aka_integer_division(self):
      self.assertEqual(120//60, 0)
      self.assertEqual(150//60, 0)

  def test_duration_w_hours_and_minutes(self):
  ...

and the terminal shows an :ref:`AssertionError`

.. code-block:: python

  AssertionError: 2 != 0

green: make it pass
------------------------------------

* I make the first expected value in the test to the correct value, the whole number result of dividing ``120`` by ``60`` is ``2`` with a remainder of ``0``

  .. code-block:: python

    def test_floor_aka_integer_division(self):
        self.assertEqual(120//60, 2)
        self.assertEqual(150//60, 0)

  the terminal shows an :ref:`AssertionError`

  .. code-block:: python

    AssertionError: 2 != 0

* I make the second expected value in the test to the correct value, the whole number result of dividing ``150`` by ``60`` is ``2`` with a remainder of ``30``

  .. code-block:: python

    def test_floor_aka_integer_division(self):
        self.assertEqual(120//60, 2)
        self.assertEqual(150//60, 2)

  the terminal shows all tests are passing

test_modulo_operation
===========================================

The ``%`` operator returns the remainder from dividing one number by another

red: make it fail
-------------------------------------------

I add a test for it

.. code-block:: python

  def test_modulo_operation(self):
      self.assertEqual(120%60, 2)
      self.assertEqual(150%60, 2)

  def test_duration_w_hours_and_minutes(self):
  ...

and the terminal shows an :ref:`AssertionError`

.. code-block:: python

  AssertionError: 0 != 2

green: make it pass
-----------------------------------------------

* I make the first expected value in the test to the correct value, the remainder from dividing ``120`` by ``60`` is ``0``

  .. code-block:: python

    def test_modulo_operation(self):
        self.assertEqual(120%60, 0)
        self.assertEqual(150%60, 2)

  and the terminal shows an :ref:`AssertionError`

  .. code-block:: python

    AssertionError: 30 != 2

* I make the second expected value in the test to the correct value, the remainder from dividing ``150`` by ``60`` is ``30``

  .. code-block:: python

    def test_modulo_operation(self):
        self.assertEqual(120%60, 0)
        self.assertEqual(150%60, 30)

  the terminal shows passing tests

----

* I remove ``duration_a`` since the working solution in ``duration`` is better
* I write a function to get the total minutes from a timestamp and call it in the ``duration`` :ref:`function<functions>`

  .. code-block:: python

    def get_total_minutes(timestamp):
        return (
            (get_hour(timestamp) * 60)
           + get_minutes(timestamp)
        )

    def duration(wake_time=None, sleep_time=None):
        wake_time_minutes = get_total_minutes(wake_time)
        sleep_time_minutes = get_total_minutes(sleep_time)
        difference = wake_time_minutes - sleep_time_minutes
        difference_hours = difference // 60
        difference_minutes = difference % 60

        return f'{difference_hours:02}:{difference_minutes:02}'

  the terminal shows passing tests. We are still green.

* I remove ``wake_time_minutes`` and ``sleep_time_minutes`` and do the calculation directly since I only use them when I calculate the difference

  .. code-block:: python

    def duration(wake_time=None, sleep_time=None):
        difference = (
            get_total_minutes(wake_time)
          - get_total_minutes(sleep_time)
        )
        difference_hours = difference // 60
        difference_minutes = difference % 60

        return f'{difference_hours:02}:{difference_minutes:02}'

  the terminal shows all tests are still passing. Take a look at the last two blocks of code. Which one do you like?

* I make a :ref:`function<functions>` to replace the ``get_hour`` and ``get_minutes`` functions

  .. code-block:: python

    def parse_timestamp(timestamp=None, index=0):
        return int(timestamp.split(':')[index])

    def get_total_minutes(timestamp):
        return (
            (parse_timestamp(timestamp, 0) * 60)
           + parse_timestamp(timestamp, 1)
        )

  the terminal shows all tests are still passing

* I remove the ``get_hour`` and ``get_minutes`` functions
* I remove ``test_duration_calculation`` since it is now covered by ``test_duration_w_hours_and_minutes``

----

test_duration_w_earlier_wake_than_sleep_time
=================================================

What happens when the ``duration`` :ref:`function<functions>` is given an earlier ``wake_time`` than ``sleep_time``?

red: make it fail
--------------------------

I add a new failing test to ``test_sleep_duration.py`` to find out

.. code-block:: python

  def test_duration_w_earlier_wake_than_sleep_time(self):
      self.assertEqual(
          sleep_duration.duration(
              wake_time='01:00',
              sleep_time='02:00'
          ),
          ''
      )

the terminal shows an :ref:`AssertionError`

.. code-block:: python

  AssertionError: '-1:00' != ''

green: make it pass
-----------------------------------

I make the expected value in the test to make it pass

.. code-block:: python

  def test_duration_w_earlier_wake_than_sleep_time(self):
      self.assertEqual(
          sleep_duration.duration(
              wake_time='01:00',
              sleep_time='02:00'
          ),
          '-1:00'
      )

I am green again

refactor: make it better
------------------------------

* The ``duration`` :ref:`function<functions>` currently returns negative numbers when given an earlier ``wake_time`` than ``sleep_time``. It measures a time traveling scenario where the traveler can go to sleep in the present and wake up in the past. I make it to make sure it only returns durations when ``wake_time`` is not earlier than ``sleep_time``, time traveling is too hard

  .. code-block:: python

    def duration(wake_time=None, sleep_time=None):
        difference = (
            get_total_minutes(wake_time)
          - get_total_minutes(sleep_time)
        )

        if difference < 0:
            raise ValueError(
                f'wake_time: {wake_time} is earlier '
                f'than sleep_time: {sleep_time}'
            )
        else:
            difference_hours = difference // 60
            difference_minutes = difference % 60
            return f'{difference_hours:02}:{difference_minutes:02}'

  - When the difference between ``wake_time`` and ``sleep_time`` is less than ``0``, it means ``wake_time`` is earlier than ``sleep_time`` and the ``duration`` :ref:`function<functions>` will raise an :doc:`Exception </how_to/exception_handling_programs>`
  - When the difference between ``wake_time`` and ``sleep_time`` is greater than or equal to ``0``, it means ``wake_time`` is later than or the same as ``sleep_time`` and the ``duration`` :ref:`function<functions>` returns the difference

  the terminal shows a ValueError_ for ``test_duration_w_earlier_wake_than_sleep_time`` and ``test_duration_w_hours_and_minutes`` for the random values where ``wake_time`` is earlier than ``sleep_time``

  .. code-block:: python

    ValueError: wake_time: 20:26 is earlier than sleep_time: 23:50

* I add the error to the list of exceptions encountered

  .. code-block:: python

    # Exceptions Encountered
    # AssertionError
    # NameError
    # AttributeError
    # TypeError
    # SyntaxError
    # ValueError

* I use `unittest.TestCase.assertRaises`_ to catch the :doc:`Exception </how_to/exception_handling_tests>` in ``test_duration_w_earlier_wake_than_sleep_time``

  .. code-block:: python

    def test_duration_w_earlier_wake_than_sleep_time(self):
        with self.assertRaises(ValueError):
            sleep_duration.duration(
                wake_time='01:00',
                sleep_time='02:00'
            )

  the test passes, leaving the ValueError_ for ``test_duration_w_hours_and_minutes``

* I add an :doc:`exception handler </how_to/exception_handling_programs>` using a `try statement`_ and `unittest.TestCase.assertRaises`_ to confirm the ValueError_ is raised when ``wake_time`` is earlier than ``sleep_time``

  .. code-block:: python

    def test_duration_w_hours_and_minutes(self):
        wake_hour = random.randint(0, 23)
        sleep_hour = random.randint(0, 23)
        wake_minutes = random.randint(0, 59)
        sleep_minutes = random.randint(0, 59)

        wake_time_minutes = (wake_hour * 60) + wake_minutes
        sleep_time_minutes = (sleep_hour * 60) + sleep_minutes
        difference = wake_time_minutes - sleep_time_minutes
        difference_hours = difference // 60
        difference_minutes = difference % 60

        wake_time = f'{wake_hour:02}:{wake_minutes:02}'
        sleep_time = f'{sleep_hour:02}:{sleep_minutes:02}'

        try:
            self.assertEqual(
                sleep_duration.duration(
                    wake_time=wake_time,
                    sleep_time=sleep_time
                ),
                f'{difference_hours:02}:{difference_minutes:02}'
            )
        except ValueError:
            with self.assertRaises(ValueError):
                sleep_duration.duration(
                    wake_time=wake_time,
                    sleep_time=sleep_time
                )

  all tests are passing. Green is a beautiful color

* I no longer need ``test_duration_w_earlier_wake_than_sleep_time`` since it is covered by ``test_duration_w_hours_and_minutes`` so I remove it
* I use `unittest.TestCase.assertRaisesRegex`_ to make sure ``test_duration_w_hours_and_minutes`` catches only the ValueError_ raised by the ``duration`` :ref:`function<functions>` with a specific message

  .. code-block:: python

    def test_duration_w_hours_and_minutes(self):
        wake_hour = random.randint(0, 23)
        sleep_hour = random.randint(0, 23)
        wake_minutes = random.randint(0, 59)
        sleep_minutes = random.randint(0, 59)

        wake_time_minutes = (wake_hour * 60) + wake_minutes
        sleep_time_minutes = (sleep_hour * 60) + sleep_minutes

        difference = wake_time_minutes - sleep_time_minutes
        difference_hours = difference // 60
        difference_minutes = difference % 60

        wake_time = f'{wake_hour:02}:{wake_minutes:02}'
        sleep_time = f'{sleep_hour:02}:{sleep_minutes:02}'

        try:
            self.assertEqual(
                sleep_duration.duration(
                    wake_time=wake_time,
                    sleep_time=sleep_time
                ),
                f'{difference_hours:02}:{difference_minutes:02}'
            )
        except ValueError:
            with self.assertRaisesRegex(
                ValueError,
                f'wake_time: {wake_time} is earlier '
                f'than sleep_time: {sleep_time}'
            ):
                sleep_duration.duration(
                    wake_time=wake_time,
                    sleep_time=sleep_time
                )

  - the terminal shows passing tests
  - `unittest.TestCase.assertRaisesRegex`_ confirms that a specific :doc:`Exception </how_to/exception_handling_tests>` with a specific message is raised.

I have a function that

* takes in a ``wake_time`` and ``sleep_time`` as inputs
* raises a ValueError_ with a message when ``wake_time`` is earlier than ``sleep_time``
* returns the difference between the two when ``wake_time`` is later than or equal to ``sleep_time``

Time to take a break.

----

test_duration_given_date_and_time
===========================================

The ``duration`` :ref:`function<functions>` has been tested with timestamps that contain only hours and minutes, but I could fall asleep on a Monday and wake up on a Tuesday. What would happen if I added dates to the timestamps?

red: make it fail
--------------------------------------------

* I add a failing test to ``test_sleep_duration.py`` based on ``test_duration_w_hours_and_minutes`` and call it ``test_duration_given_date_and_time`` to test the ``duration`` function with a date, hours and minutes

  .. code-block:: python

    def test_duration_given_date_and_time(self):
        wake_hour = random.randint(0, 23)
        sleep_hour = random.randint(0, 23)
        wake_minutes = random.randint(0, 59)
        sleep_minutes = random.randint(0, 59)

        wake_time_minutes = (wake_hour * 60) + wake_minutes
        sleep_time_minutes = (sleep_hour * 60) + sleep_minutes

        difference = wake_time_minutes - sleep_time_minutes
        difference_hours = difference // 60
        difference_minutes = difference % 60

        wake_time = f'31/12/99 {wake_hour:02}:{wake_minutes:02}'
        sleep_time = f'31/12/99 {sleep_hour:02}:{sleep_minutes:02}'

        try:
            self.assertEqual(
                sleep_duration.duration(
                    wake_time=wake_time,
                    sleep_time=sleep_time
                ),
                f'{difference_hours:02}:{difference_minutes:02}'
            )
        except ValueError:
            with self.assertRaisesRegex(
                ValueError,
                f'wake_time: {wake_time} is earlier '
                f'than sleep_time: {sleep_time}'
            ):
                sleep_duration.duration(
                    wake_time=wake_time,
                    sleep_time=sleep_time
                )

  the terminal shows an :ref:`AssertionError`

  .. code-block:: python

    AssertionError: "wake_time: 31/12/99 10:07 is earlier than sleep_time: 31/12/99 05:25" does not match "invalid literal for int() with base 10: '31/12/99 10'"

  it looks like the ``duration`` :ref:`function<functions>` encountered a ValueError_ with a different message than the one the test expects. The `unittest.TestCase.assertRaisesRegex`_ works. If I did not specify the error message to catch, the test would have missed this

green: make it pass
-------------------------

* The ``parse_timestamp`` function tried to convert the given string_ to an integer but it is in the wrong format

  .. code-block:: python

    invalid literal for int() with base 10: '31/12/99 10'

* The `str.split`_ :ref:`method<functions>` was given a separator of ``':'`` when the timestamp contained only hours and minutes, but it behaves differently when I add a date. I add a test for it to ``test_string_splitting``

  .. code-block:: python

    self.assertEqual(
        '31/12/99 10:07'.split(':')[0],
        ''
    )

  the terminal shows an :ref:`AssertionError`

  .. code-block:: python

    AssertionError: '31/12/99 10' != ''

* I update the test with the correct values to make it pass

  .. code-block:: python

    self.assertEqual(
        '31/12/99 10:07'.split(':')[0],
        '31/12/99 10'
    )

  I cannot convert a string_ in the format ``'31/12/99 10'`` to an integer

* I disable ``test_duration_given_date_and_time`` by adding the `unittest.skip decorator`_

  .. code-block:: python

    ...
    @unittest.skip
    def test_duration_given_date_and_time(self):
    ...

* then add a test to ``test_converting_string_to_integer`` to confirm the cause of the ValueError_

  .. code-block:: python

    def test_converting_string_to_integer(self):
        self.assertEqual(int('12'), 12)
        self.assertEqual(int('01'), 1)
        int('31/12/99 10')

  the terminal shows a ValueError_ with the same message from ``test_duration_given_date_and_time``

  .. code-block:: python

    ValueError: invalid literal for int() with base 10: '31/12/99 10'

* I use `unittest.TestCase.assertRaises`_ to catch the ValueError_ and I am green again

  .. code-block:: python

    def test_converting_string_to_integer(self):
        self.assertEqual(int('12'), 12)
        self.assertEqual(int('01'), 1)

        with self.assertRaises(ValueError):
            int('31/12/99 10')

* I need a solution that can read the date and time. Writing one myself requires knowing the number of days in months for a specific year.

    Thirty days has September
    April, June and November,
    All the rest have thirty-one,
    Except February, twenty-eight days clear
    and twenty-nine in each leap year

  I search for `time difference <https://docs.python.org/3/search.html?q=time+difference>`_ in the `python online documentation`_ to see if there is an existing solution, and select the datetime_ module since it looks like the solution to this problem. Reading through the available types in the module, I see I can create `datetime.datetime`_ objects which handle date and time

  .. code-block:: python

    class datetime.datetime
      A combination of a date and a time.
        Attributes: year, month, day, hour,
        minute, second, microsecond, and tzinfo.

  I also see `datetime.timedelta`_ objects which are the difference between two `datetime.datetime`_ instances

  .. code-block:: python

    class datetime.timedelta
      A duration expressing the difference between
        two date, time, or datetime instances to
        microsecond resolution.


* I add tests using the examples in the documentation to help me understand how to use the datetime_ module

test_datetime_datetime_objects
======================================

red: make it fail
--------------------------------------

* I add a test to ``test_sleep_duration.py`` based on `Examples of usage: datetime <https://docs.python.org/3/library/datetime.html?highlight=time%20difference#examples-of-usage-datetime>`_ for `datetime.datetime`_ objects

  .. code-block:: python

    def test_datetime_datetime_objects(self):
        self.assertEqual(
            datetime.datetime.strptime(
                '21/11/06 16:30',
                '%d/%m/%y %H:%M'
            ),
            ''
        )

    def test_duration_w_hours_and_minutes(self):
    ...

* the terminal shows a NameError_ because ``datetime`` is not defined in ``test_sleep_duration.py``. I need to import it

  .. code-block:: python

    NameError: name 'datetime' is not defined. Did you forget to import 'datetime'

* I add an `import statement`_ for the datetime_ module to ``test_sleep_duration.py``

  .. code-block:: python

    import datetime
    import random
    import sleep_duration
    import unittest
    ...

  the terminal shows an :ref:`AssertionError`

  .. code-block:: python

    AssertionError: datetime.datetime(2006, 11, 21, 16, 30) != ''

* I copy the value on the left side of the :ref:`AssertionError` to replace the expected value in the test

  .. code-block:: python

    def test_datetime_datetime_objects(self):
        self.assertEqual(
            datetime.datetime.strptime(
                '21/11/06 16:30',
                '%d/%m/%y %H:%M'
            ),
            datetime.datetime(2006, 11, 21, 16, 30)
        )

  and the terminal shows passing tests

From the test I see that

* `datetime.datetime`_ takes ``year``, ``month``, ``date``, ``hours`` and ``minutes`` as inputs
* the `datetime.datetime.strptime`_ :ref:`method<functions>` takes 2 strings_ as inputs - a timestamp and a pattern, and returns a `datetime.datetime`_ object
* it also looks like the pattern provided represents the following

  - ``%d`` is for days
  - ``%m`` is for months
  - ``%y`` is for 2 digit years
  - ``%H`` is for hours
  - ``%M`` is for minutes

test_subtracting_datetime_datetime_objects
========================================================

red: make it fail
--------------------------------------------------------

* I add a test based on `Examples of usage: timedelta <https://docs.python.org/3/library/datetime.html?highlight=time%20difference#examples-of-usage-timedelta>`_ for subtracting two `datetime.datetime`_ objects

  .. code-block:: python

    def test_subtracting_datetime_datetime_objects(self):
        sleep_time = datetime.datetime.strptime(
            '21/11/06 16:30', '%d/%m/%y %H:%M'
        )
        wake_time = datetime.datetime.strptime(
            '21/11/06 17:30', '%d/%m/%y %H:%M'
        )
        self.assertEqual(wake_time-sleep_time, 1)

* I can add a variable to remove the duplication of the timestamp pattern

  .. code-block:: python

    def test_subtracting_datetime_datetime_objects(self):
        pattern = '%d/%m/%y %H:%M'
        sleep_time = datetime.datetime.strptime(
            '21/11/06 16:30', pattern
        )
        wake_time = datetime.datetime.strptime(
            '21/11/06 17:30', pattern
        )
        self.assertEqual(wake_time-sleep_time, 1)

    def test_duration_w_hours_and_minutes(self):
    ...

  the terminal shows an :ref:`AssertionError`

  .. code-block:: python

    AssertionError: datetime.timedelta(seconds=3600) != 1

green: make it pass
--------------------------------------------------------

* I copy the value on the left of the :ref:`AssertionError` and replace the expected value in the test

  .. code-block:: python

    def test_subtracting_datetime_datetime_objects(self):
        pattern = '%d/%m/%y %H:%M'
        sleep_time = datetime.datetime.strptime(
            '21/11/06 16:30', pattern
        )
        wake_time = datetime.datetime.strptime(
            '21/11/06 17:30', pattern
        )
        self.assertEqual(
            wake_time-sleep_time,
            datetime.timedelta(seconds=3600)
        )

With these passing tests. I see that I can

- convert a string_ to a `datetime.datetime`_ object
- subtract one `datetime.datetime`_ object from another to get a `datetime.timedelta`_ object

test_converting_timedelta_to_string
========================================================

red: make it fail
--------------------------------------------------------

* So far the `datetime.timedelta`_ object I get shows seconds, but I want the result as a string. I add a test to see if I can change it to a string_ using the str_ constructor

  .. code-block:: python

    def test_converting_timedelta_to_string(self):
        self.assertEqual(
            str(datetime.timedelta(seconds=7200)),
            ''
        )

    def test_duration_w_hours_and_minutes(self):
    ...

  and I get an :ref:`AssertionError` with a message that looks more like what I want

  .. code-block:: python

    AssertionError: '2:00:00' != ''

green: make it pass
--------------------------------------------------------

* I make the expected value in the test to match the value from the terminal

  .. code-block:: python

    def test_converting_timedelta_to_string(self):
        self.assertEqual(
            str(datetime.timedelta(seconds=7200)),
            '2:00:00'
        )

  it looks like calling str_ on a `datetime.timedelta`_ object returns a string_ in the format ``Hours:Minutes:Seconds``

From the tests, I know I can

* convert a string_ to a `datetime.datetime`_ object
* subtract one `datetime.datetime`_ object from another to get a `datetime.timedelta`_ object
* convert a `datetime.timedelta`_ object to a string_

----

* I remove ``@unittest.skip`` from ``test_duration_given_date_and_time`` to return to the ValueError_ that sent me down this path
* I add a function for converting timestamps to ``sleep_duration.py`` and call it ``get_datetime_object``

  .. code-block:: python

    def get_datetime_object(timestamp):
        return datetime.datetime.strptime(
            timestamp, '%d/%m/%y %H:%M'
        )

    def duration(wake_time=None, sleep_time=None):
    ...

* I rename ``duration`` to ``duration_a``

  .. code-block:: python

    def duration_a(wake_time=None, sleep_time=None):
        difference = (
            get_total_minutes(wake_time)
          - get_total_minutes(sleep_time)
        )

        if difference < 0:
            raise ValueError(
                f'wake_time: {wake_time} is earlier '
                f'than sleep_time: {sleep_time}'
            )
        else:
            difference_hours = difference // 60
            difference_minutes = difference % 60
            return f'{difference_hours:02}:{difference_minutes:02}'

* then add a new ``duration`` :ref:`function<functions>` with a call to the ``get_datetime_object``

  .. code-block:: python

    def duration(wake_time=None, sleep_time=None):
        difference = (
            get_datetime_object(wake_time)
          - get_datetime_object(sleep_time)
        )
        return str(difference)

  the terminal shows a NameError_

  .. code-block:: python

    NameError: name 'datetime' is not defined. Did you forget to import 'datetime'

  I encountered this earlier when testing the datetime_ module

* I add an `import statement`_ to the top of ``sleep_duration.py``

  .. code-block:: python

    import datetime

    def parse_timestamp(timestamp=None, index=0):
    ...

  the terminal shows an :ref:`AssertionError` for ``test_duration_w_hours_and_minutes`` that looks like this

  .. code-block:: python

    AssertionError: "wake_time: 10:52 is earlier than sleep_time: 04:00" does not match "time data '10:52' does not match format '%d/%m/%y %H:%M'"

  I have another ValueError_ this time for a timestamp that does not match the expected pattern of ``'%d/%m/%y %H:%M'``

* ``test_duration_w_hours_and_minutes`` currently sends the timestamps in without a date, so I remove it since it is covered by ``test_duration_given_date_and_time``

  the terminal shows an :ref:`AssertionError` that looks like this

  .. code-block:: python

    AssertionError: '8:50:00' != '08:50'

* I update ``test_duration_given_date_and_time`` to use the right format and remove unused variables

  .. code-block:: python

    def test_duration_given_date_and_time(self):
        wake_hour = random.randint(0, 23)
        sleep_hour = random.randint(0, 23)
        wake_minutes = random.randint(0, 59)
        sleep_minutes = random.randint(0, 59)

        wake_time = f'31/12/99 {wake_hour:02}:{wake_minutes:02}'
        sleep_time = f'31/12/99 {sleep_hour:02}:{sleep_minutes:02}'
        pattern = '%d/%m/%y %H:%M'

        difference = (
            datetime.datetime.strptime(wake_time, pattern)
          - datetime.datetime.strptime(sleep_time, pattern)
        )

        try:
            self.assertEqual(
                sleep_duration.duration(
                    wake_time=wake_time,
                    sleep_time=sleep_time
                ),
                str(difference)
            )
        except ValueError:
            with self.assertRaisesRegex(
                ValueError,
                f'wake_time: {wake_time} is earlier '
                f'than sleep_time: {sleep_time}'
            ):
                sleep_duration.duration(
                    wake_time=wake_time,
                    sleep_time=sleep_time
                )

  the terminal shows passing tests

* Before I remove ``duration_a``, I update ``duration`` to do a comparison of ``wake_time`` and ``sleep_time`` so it raises a ValueError_ when ``wake_time`` is earlier than ``sleep_time``

  .. code-block:: python

    def duration(wake_time=None, sleep_time=None):
        wake_time = get_datetime_object(wake_time)
        sleep_time = get_datetime_object(sleep_time)

        if wake_time < sleep_time:
            raise ValueError(
                f'wake_time: {wake_time} is earlier '
                f'than sleep_time: {sleep_time}'
            )
        else:
            difference = wake_time - sleep_time
            return str(difference)

  the terminal shows an :ref:`AssertionError` that looks like this

  .. code-block:: python

    AssertionError: "wake_time: 31/12/99 17:23 is earlier than sleep_time: 31/12/99 19:07" does not match "wake_time: 1999-12-31 17:23:00 is earlier than sleep_time: 1999-12-31 19:07:00"

  there is a ValueError_ with a different message than the one the `unittest.TestCase.assertRaisesRegex`_ is expecting. The timestamp formats do not match because the ``duration`` :ref:`function<functions>` uses the `datetime.datetime.strptime`_ objects in the message when it raises the exception and ``test_duration_given_date_and_time`` does not

* I make ``test_duration_given_date_and_time`` to use the right error message

  .. code-block:: python

    def test_duration_given_date_and_time(self):
        wake_hour = random.randint(0, 23)
        sleep_hour = random.randint(0, 23)
        wake_minutes = random.randint(0, 59)
        sleep_minutes = random.randint(0, 59)

        wake_time = f'31/12/99 {wake_hour:02}:{wake_minutes:02}'
        sleep_time = f'31/12/99 {sleep_hour:02}:{sleep_minutes:02}'
        pattern = '%d/%m/%y %H:%M'

        difference = (
            datetime.datetime.strptime(wake_time, pattern)
          - datetime.datetime.strptime(sleep_time, pattern)
        )

        try:
            self.assertEqual(
                sleep_duration.duration(
                    wake_time=wake_time,
                    sleep_time=sleep_time
                ),
                str(difference)
            )
        except ValueError:
            with self.assertRaisesRegex(
                ValueError,
                f'wake_time: {datetime.datetime.strptime(wake_time, pattern)} is earlier '
                f'than sleep_time: {datetime.datetime.strptime(sleep_time, pattern)}'
            ):
                sleep_duration.duration(
                    wake_time=wake_time,
                    sleep_time=sleep_time
                )

  and things are green again, all the tests are passing

refactor: make it better
--------------------------------------------------------

* I remove some repetition from ``test_duration_given_date_and_time`` by using variables for the datetime objects

  .. code-block:: python

    def test_duration_given_date_and_time(self):
        wake_hour = random.randint(0, 23)
        sleep_hour = random.randint(0, 23)
        wake_minutes = random.randint(0, 59)
        sleep_minutes = random.randint(0, 59)

        wake_time = f'31/12/99 {wake_hour:02}:{wake_minutes:02}'
        sleep_time = f'31/12/99 {sleep_hour:02}:{sleep_minutes:02}'
        pattern = '%d/%m/%y %H:%M'

        wake_datetime_object = datetime.datetime.strptime(
            wake_time, pattern
        )
        sleep_datetime_object = datetime.datetime.strptime(
            sleep_time, pattern
        )

        difference = (
            wake_datetime_object
          - sleep_datetime_object
        )

        try:
            self.assertEqual(
                sleep_duration.duration(
                    wake_time=wake_time,
                    sleep_time=sleep_time
                ),
                str(difference)
            )
        except ValueError:
            with self.assertRaisesRegex(
                ValueError,
                f'wake_time: {wake_datetime_object} is earlier '
                f'than sleep_time: {sleep_datetime_object}'
            ):
                sleep_duration.duration(
                    wake_time=wake_time,
                    sleep_time=sleep_time
                )

* I remove ``duration_a`` from ``sleep_duration.py`` since I have a better solution in ``duration``
* I remove ``parse_timestamp`` and ``get_total_minutes`` since they are no longer used
* I remove the ``difference`` variable from ``duration`` since it is only called once

  .. code-block:: python

    def duration(wake_time=None, sleep_time=None):
        wake_time = get_datetime_object(wake_time)
        sleep_time = get_datetime_object(sleep_time)

        if wake_time < sleep_time:
            raise ValueError(
                f'wake_time: {wake_time} is earlier '
                f'than sleep_time: {sleep_time}'
            )
        else:
            return str(wake_time-sleep_time)

review
========================================================

The challenge was to create a function that calculates the difference between two given timestamps.

To make it happen I

* :ref:`test_string_attributes_and_methods`
* `test_string_splitting`_ where I

  - used the `help system`_ to view documentation
  - split a string_ into a :doc:`list </data_structures/lists/lists>` using a separator
  - indexed a :doc:`list </data_structures/lists/lists>` to get specific items

* `test_converting_string_to_integer`_
* `test_floor_aka_integer_division`_
* `test_modulo_operation`_
* `test_datetime_datetime_objects`_ where I

  - used the `python online documentation`_
  - converted a string_ to a `datetime.datetime`_ object using the `datetime.datetime.strptime`_ :ref:`method<functions>`

* :ref:`test_subtracting_datetime_datetime_objects`
* `test_converting_timedelta_to_string`_
* `test_duration_given_date_and_time`_

  - using `random.randint`_ to generate a random integer
  - using a random timestamp ranging from ``'00:00'`` up to and including ``'23:59'`` as inputs for ``wake_time`` and ``sleep_time``
  - confirming a ValueError_ is raised when ``wake_time`` is earlier than ``sleep_time``
  - `test_duration_w_hours`_
  - `test_duration_w_hours_and_minutes`_
  - `test_duration_calculation`_
  - `test_duration_w_earlier_wake_than_sleep_time`_

I also encountered the following exceptions

* :ref:`AssertionError`
* NameError_
* :ref:`AttributeError`
* :ref:`TypeError`
* SyntaxError_
* ValueError_

----

:doc:`/code/code_sleep_duration`
