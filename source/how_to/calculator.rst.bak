.. meta::
  :description: Learn Test-Driven Development in Python by building a calculator from scratch. This tutorial covers writing tests, handling exceptions, and refactoring.
  :keywords: Jacob Itegboje, python tdd calculator tutorial, test driven development python example, python calculator tutorial for beginners, python tdd workflow, python unit testing tutorial, how to build a calculator in python step-by-step, python test driven development with pytest, python programming projects for beginners

.. include:: ../links.rst

#################################################################################
how to make a calculator
#################################################################################

.. raw:: html

  <iframe style="border-radius:12px" width="560"  height="315" src="https://www.youtube-nocookie.com/embed/i8fGEqdH3yk?si=eBow2hwdlh01aVUF" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

----

I want to write a program_ that can ``add``, ``subtract``, ``multiply`` and ``divide``

*********************************************************************************
preview
*********************************************************************************

Here are the tests I have by the end of the chapter

.. literalinclude:: ../code/tests/test_calculator.py
  :language: python
  :linenos:

----

*********************************************************************************
start the project
*********************************************************************************

* I name this project ``calculator``
* I open a terminal_
* then I `make a directory`_ for the project

  .. code-block:: shell
    :emphasize-lines: 1

    mkdir calculator

  the terminal_ goes back to the command line

  .. code-block:: shell

    .../pumping_python

* I `change directory`_ to the project

  .. code-block:: shell
    :emphasize-lines: 1

    cd calculator

  the terminal_ shows I am now in the ``calculator`` folder_

  .. code-block:: shell

    .../pumping_python/calculator

* I `make a folder`_ for the source code

  .. code-block:: shell
    :emphasize-lines: 1

    mkdir src

  the terminal_ goes back to the command line

  .. code-block:: shell

    .../pumping_python/calculator

* I use touch_ to make an empty file_ for the program_ in the ``src`` folder_

  .. code-block:: shell
    :emphasize-lines: 1

    touch src/calculator.py

  .. attention::

    on Windows_ without `Windows Subsystem for Linux`_ use ``New-Item src/calculator.py`` instead of ``touch src/calculator.py``

    .. code-block:: shell
      :emphasize-lines: 1

      New-Item src/calculator.py

  the terminal_ goes back to the command line

  .. code-block:: shell

    .../pumping_python/calculator

* I `make a directory`_ for the tests

  .. code-block:: shell
    :emphasize-lines: 1

    mkdir tests

  the terminal_ goes back to the command line

* I use touch_ to make an empty file_ in the ``tests`` folder_ to tell Python_ that it is a `Python package`_

  .. ATTENTION:: use 2 underscores (__) before and after ``init`` for ``__init__.py`` not ``_init_.py``

  .. code-block:: shell
    :emphasize-lines: 1

    touch tests/__init__.py

  .. attention::

    on Windows_ without `Windows Subsystem for Linux`_ use ``New-Item tests/__init__.py`` instead of ``touch tests/__init__.py``

    .. code-block:: shell
      :emphasize-lines: 1

      New-Item tests/__init__.py

  the terminal_ goes back to the command line

* I make an empty file_ for the actual test

  .. code-block:: shell
    :emphasize-lines: 1

    touch tests/test_calculator.py

  .. attention::

    on Windows_ without `Windows Subsystem for Linux`_ use ``New-Item tests/test_calculator.py`` instead of ``touch tests/test_calculator.py``

    .. code-block:: shell
      :emphasize-lines: 1

      New-Item tests/test_calculator.py

  the terminal_ goes back to the command line

* I open ``test_calculator.py`` in the :ref:`editor<2 editors>` of the `Integrated Development Environment (IDE)`_

  .. TIP:: I can open a file_ from the terminal_ in `Visual Studio Code`_ by typing ``code`` and the name of the file_ with

    .. code-block:: shell
      :emphasize-lines: 1

      code tests/test_calculator.py

    ``test_calculator.py`` opens up in the :ref:`editor<2 editors>`

* I add :ref:`the first failing test<test_failure>` to ``test_calculator.py``

  .. code-block:: python
    :linenos:
    :emphasize-lines: 1, 4, 6-7

    import unittest


    class TestCalculator(unittest.TestCase):

        def test_failure(self):
            self.assertFalse(True)

* I make a `virtual environment`_ in the terminal_

  .. code-block:: shell
    :emphasize-lines: 1

    python3 -m venv .venv

  .. attention::

    on Windows_ without `Windows Subsystem for Linux`_ use ``python3 -m venv .venv`` instead of ``python3 -m venv .venv``

    .. code-block:: shell
      :emphasize-lines: 1

      python -m venv .venv

  the terminal_ takes some time then goes back to the command line

* I activate the `virtual environment`_

  .. code-block:: shell
    :emphasize-lines: 1

    source .venv/bin/activate

  .. attention::

    on Windows_ without `Windows Subsystem for Linux`_ use ``.venv/bin/activate.ps1`` instead of ``source .venv/bin/activate``

    .. code-block:: shell
      :emphasize-lines: 1

      .venv/scripts/activate.ps1

  the terminal_ shows

  .. code-block:: shell

    (.venv) .../pumping_python/calculator

* I upgrade the `Python package manager (pip)`_ to the latest version

  .. code-block:: shell
    :emphasize-lines: 1

    python3 -m pip install --upgrade pip

  the terminal_ shows pip_ being uninstalled then installs the latest version or shows that it is already the latest version

* I make a ``requirements.txt`` file for the `Python programs`_ my project needs

  .. code-block:: shell
    :emphasize-lines: 1

    echo "pytest-watch" > requirements.txt

  the terminal_ goes back to the command line

* I use pip_ to use the requirements file_ to install ``pytest-watch``

  .. code-block:: shell
    :emphasize-lines: 1

    python3 -m pip install --requirement requirements.txt

  .. attention::

    on Windows_ without `Windows Subsystem for Linux`_ use ``python -m pip install --requirement requirements.txt`` instead of ``python3 -m pip install --requirement requirements.txt``

    .. code-block:: shell
      :emphasize-lines: 1

      python -m pip install --requirement requirements.txt

  the terminal_ shows pip_ downloads and installs the `Python programs`_ that `pytest-watch`_ needs to run

* I use `pytest-watch`_ to run the test

  .. code-block:: shell
    :emphasize-lines: 1

    pytest-watch

  the terminal_ shows

  .. code-block:: shell
    :emphasize-lines: 8, 10

    ================================ FAILURES ================================
    _____________________ TestCalculator.test_failure ________________________

    self = <tests.test_calculator.TestCalculator testMethod=test_failure>

        def test_failure(self):
    >       self.assertFalse(True)
    E       AssertionError: True is not false

    tests/test_calculator.py:7: AssertionError
    ======================== short test summary info =========================
    FAILED tests/test_calculator.py::TestCalculator::test_failure - AssertionError: True is not false
    =========================== 1 failed in X.YZs ============================

* I hold :kbd:`ctrl` (Windows_/Linux_) or :kbd:`option` or :kbd:`command` (MacOS_) on the keyboard and use the mouse to click on ``tests/test_calculator.py:7`` to open it in the :ref:`editor<2 editors>`

* I add :ref:`AssertionError` to the list of :ref:`Exceptions<errors>` seen in ``test_calculator.py``

  .. code-block:: python
    :lineno-start: 7
    :emphasize-lines: 4-5

            self.assertFalse(True)


    # Exceptions seen
    # AssertionError

* then I change :ref:`True<test_what_is_true>` to :ref:`False<test_what_is_false>` in the :ref:`assertion<what is an assertion?>`

  .. code-block:: python
    :lineno-start: 7
    :emphasize-lines: 1

            self.assertFalse(False)

  the test passes

----

* I add a TODO list to keep track of the work for the program

  .. code-block:: python
    :linenos:
    :emphasize-lines: 10-14

    import unittest


    class TestCalculator(unittest.TestCase):

        def test_failure(self):
            self.assertFalse(False)


    # TODO
    # test addition
    # test subtraction
    # test multiplication
    # test division


    # Exceptions seen
    # AssertionError

*********************************************************************************
test_addition
*********************************************************************************

* I change ``test_failure`` to ``test_addition`` then change `assertFalse`_ to `assertEqual`_

  .. code-block:: python
    :linenos:
    :emphasize-lines: 6-10

    import unittest


    class TestCalculator(unittest.TestCase):

        def test_addition(self):
            self.assertEqual(
                src.calculator.add(0, 1),
                1
            )

  - the `assertEqual method`_ from the `unittest.TestCase class`_ checks if its 2 inputs are the same. It is like the statement ``assert x == y`` or asking ``is x equal to y?``
  - the explanation I like from what I have seen is that one of them is

    - ``reality`` - ``src.calculator.add(0, 1)``, and the other is my
    - ``expectation`` - ``1``, because ``0`` plus ``1`` is ``1``

  the terminal_ shows :ref:`NameError<test_catching_name_error_in_tests>`

  .. code-block:: shell

    NameError: name 'src' is not defined

  because ``src`` is not defined in ``test_calculator.py``

=================================================================================
:green:`GREEN`: make it pass
=================================================================================

* I add the error to the list of :ref:`Exceptions<errors>` seen in ``test_calculator.py``

  .. code-block:: python
    :lineno-start: 20
    :emphasize-lines: 3

    # Exceptions seen
    # AssertionError
    # NameError

* then I add an `import statement`_ at the top of the file

  .. code-block:: python
    :linenos:
    :emphasize-lines: 1

    import src.calculator
    import unittest


    class TestCalculator(unittest.TestCase):

  the terminal_ shows :ref:`AttributeError`

  .. code-block:: shell

    AttributeError: module 'src.calculator' has no attribute 'add'

  I think of ``src.calculator.add`` as an address, ``add`` is something (an :ref:`attribute<AttributeError>`) in the empty ``calculator.py`` file from the ``src`` `folder (directory)`_

* I add the error to the list of :ref:`Exceptions<errors>` seen in ``test_calculator.py``

  .. code-block:: python
    :lineno-start: 21
    :emphasize-lines: 4

    # Exceptions seen
    # AssertionError
    # NameError
    # AttributeError

* then I open ``calculator.py`` from the ``src`` folder in the :ref:`editor<2 editors>`, and I type the name

  .. code-block:: python
    :linenos:

    add

  the terminal_ shows :ref:`NameError<test_catching_name_error_in_tests>`

  .. code-block:: shell

    NameError: name 'add' is not defined

* I point it to :ref:`None`

  .. code-block:: python
    :linenos:

    add = None

  the terminal_ shows :ref:`TypeError`

  .. code-block:: shell

    TypeError: 'NoneType' object is not callable

  because the ``add`` :ref:`variable<test_attribute_error_w_variables>` is :ref:`None` which is not callable_

* I add the error to the list of :ref:`Exceptions<errors>` seen in ``test_calculator.py``

  .. code-block:: python
    :lineno-start: 21
    :emphasize-lines: 5

    # Exceptions seen
    # AssertionError
    # NameError
    # AttributeError
    # TypeError

* then I change ``add`` to a :ref:`function<functions>` to make it callable_ with the def_ keyword in ``calculator.py``

  .. code-block:: python
    :linenos:

    def add():
        return None

  the terminal_ shows :ref:`TypeError`

  .. code-block:: shell

    TypeError: add() takes 0 positional arguments but 2 were given

  the definition of ``add`` does not take input, but 2 were given in the call ``src.calculator.add(0, 1)`` - ``0`` and ``1``

* I make it take 2 arguments

  .. code-block:: python
    :linenos:
    :emphasize-lines: 1

    def add(first_input, second_input):
        return None

  the terminal_ shows :ref:`AssertionError`

  .. code-block:: shell

    AssertionError: None != 1

  the ``add`` :ref:`function<functions>` returns :ref:`None`, the test expects ``1``

* I make the `return statement`_ match the expected value

  .. code-block:: python
    :linenos:
    :emphasize-lines: 2

    def add(first_input, second_input):
        return 1

  the test passes, time for a victory lap!

=================================================================================
:yellow:`REFACTOR`: make it better
=================================================================================

The ``add`` :ref:`function<functions>` passes the test but does not meet the actual requirement because it always returns ``1``. I want it to do a calculation with the inputs and return the result

:red:`RED`: make it fail
---------------------------------------------------------------------------------

To show the problem with the :ref:`function<functions>`, I add another :ref:`assertion<what is an assertion?>` in ``test_calculator.py``

.. code-block:: python
  :lineno-start: 7
  :emphasize-lines: 6-9

        def test_addition(self):
            self.assertEqual(
                src.calculator.add(0, 1),
                1
            )
            self.assertEqual(
                src.calculator.add(-1, 1),
                0
            )

the terminal_ shows :ref:`AssertionError`

.. code-block:: python

  E    AssertionError: 1 != 0

the :ref:`function<functions>` returns ``1``, the test expects ``0``

:green:`GREEN`: make it pass
---------------------------------------------------------------------------------

when I change the `return statement`_ in ``calculator.py`` to add the two inputs

.. code-block:: python
  :linenos:
  :emphasize-lines: 2

  def add(first_input, second_input):
      return first_input + second_input

the test passes

:yellow:`REFACTOR`: make it better
---------------------------------------------------------------------------------

* I want the test to use random numbers instead of numbers that do not change, so I add an `import statement`_ at the top of ``test_calculator.py`` to use random numbers in the test

  .. code-block:: python
    :linenos:
    :emphasize-lines: 1

    import random
    import src.calculator
    import unittest

  random_ is a :ref:`module<ModuleNotFoundError>` from the `Python standard library`_ that is used to make fake random numbers

* then I add :ref:`variables <test_attribute_error_w_variables>` and a new :ref:`assertion<what is an assertion?>`

  .. code-block:: python
    :lineno-start: 6
    :emphasize-lines: 4-5, 7-10

    class TestCalculator(unittest.TestCase):

        def test_addition(self):
            random_first_number = random.randint(-1, 1)
            random_second_number = random.randint(-1, 1)

            self.assertEqual(
                src.calculator.add(random_first_number, random_second_number),
                random_first_number+random_first_number
            )
            self.assertEqual(
                src.calculator.add(0, 1),
                1
            )
            self.assertEqual(
                src.calculator.add(-1, 1),
                0
            )

  I hit save (:kbd:`ctrl+s` (Windows/Linux) or :kbd:`command+s` (mac)) a few times in the :ref:`editor<2 editors>` to run the tests and the terminal_ shows random success or :ref:`AssertionError` with random values that look like this

  .. code-block:: shell

    AssertionError: X != Y

  I change the expectation of the :ref:`assertion<what is an assertion?>` in the test to the correct calculation

  .. code-block:: python
    :lineno-start: 12
    :emphasize-lines: 3

            self.assertEqual(
                src.calculator.add(random_first_number, random_second_number),
                random_first_number+random_second_number
            )

  the test passes

  - ``random.randint(-1, 1)`` returns a random number from ``-1`` up to and including ``1``

    - ``-1`` for negative numbers
    - ``0`` for ``0``
    - ``1`` for positive numbers

* I remove the other :ref:`assertions<what is an assertion?>` because they are covered by the one that uses random numbers. I do not need them anymore

  .. code-block:: python
    :lineno-start: 6

    class TestCalculator(unittest.TestCase):

        def test_addition(self):
            random_first_number = random.randint(-1, 1)
            random_second_number = random.randint(-1, 1)

            self.assertEqual(
                src.calculator.add(random_first_number, random_second_number),
                random_first_number+random_second_number
            )


    # TODO

* There is some duplication, I have to make a change in more than one place when I want to use a different range of random numbers for the test

  .. code-block:: python
    :lineno-start: 8
    :emphasize-lines: 2-3

        def test_addition(self):
            random_first_number = random.randint(-10, 10)
            random_second_number = random.randint(-10, 10)

  I add a :ref:`function<functions>` to remove the repetition

  .. code-block:: python
    :linenos:
    :emphasize-lines: 6-7

    import random
    import src.calculator
    import unittest


    def a_random_number():
        return random.randint(-1, 1)


    class TestCalculator(unittest.TestCase):

  then I use the new :ref:`function<functions>` for the ``random_first_number`` and ``random_second_number`` :ref:`variables<what is a variable?>` in ``test_addition``

  .. code-block:: python
    :lineno-start: 12
    :emphasize-lines: 2-3

        def test_addition(self):
            random_first_number = a_random_number()
            random_second_number = a_random_number()

  I now only need to change the range of random numbers for the test in one place

  .. code-block:: python
    :lineno-start: 6
    :emphasize-lines: 2

    def a_random_number():
        return random.randint(-10, 10)

  and the terminal_ still shows green. I can use any range of numbers the computer can handle, for example

  .. code-block:: python
    :lineno-start: 6
    :emphasize-lines: 2

    def a_random_number():
        return random.randint(-10**100000, 10**100000)

  the test is still green and takes longer to run. ``10**100000`` is how to write ``10`` raised to the power of ``100,000``. I change the range back to ``-10, 10`` to keep the test running fast

  .. code-block:: python
    :lineno-start: 6
    :emphasize-lines: 2

    def a_random_number():
        return random.randint(-10, 10)

* then I remove ``test addition`` from the TODO list

  .. code-block:: python
    :lineno-start: 22

    # TODO
    # test subtraction
    # test multiplication
    # test division

----

*********************************************************************************
test_subtraction
*********************************************************************************

=================================================================================
:red:`RED`: make it fail
=================================================================================

* I add a test for subtraction in ``test_calculator.py``

  .. code-block:: python
    :lineno-start: 10
    :emphasize-lines: 12-19

    class TestCalculator(unittest.TestCase):

        def test_addition(self):
            random_first_number = a_random_number()
            random_second_number = a_random_number()

            self.assertEqual(
                src.calculator.add(first_input, second_input),
                random_first_number+random_second_number
            )

        def test_subtraction(self):
            random_first_number = a_random_number()
            random_second_number = a_random_number()

            self.assertEqual(
                src.calculator.subtract(random_first_number, random_second_number),
                random_first_number-random_second_number
            )

  the terminal_ shows :ref:`AttributeError`

  .. code-block:: shell

    AttributeError: module 'src.calculator' has no attribute 'subtract'

=================================================================================
:green:`GREEN`: make it pass
=================================================================================

* I add the name to ``calculator.py``

  .. code-block:: python
    :linenos:
    :emphasize-lines: 5

    def add(first_input, second_input):
        return first_input + second_input


    subtract

  the terminal_ shows :ref:`NameError<test_catching_name_error_in_tests>`

  .. code-block:: shell

    NameError: name 'subtract' is not defined

  I point ``subtract`` to :ref:`None`

  .. code-block:: python
    :lineno-start: 5

    subtract = None

  the terminal_ shows :ref:`TypeError`

  .. code-block:: shell

    TypeError: 'NoneType' object is not callable

  I have seen this before

* I change ``subtract`` to a :ref:`function<functions>` to make it callable_

  .. code-block:: python
    :lineno-start: 5
    :emphasize-lines: 1-2

    def subtract():
        return None

  the terminal_ shows :ref:`TypeError`

  .. code-block:: shell

    TypeError: subtract() takes 0 positional arguments but 2 were given

* I make ``subtract`` take inputs

  .. code-block:: python
    :lineno-start: 5
    :emphasize-lines: 1

    def subtract(first_input, second_input):
        return None

  I hit save (:kbd:`ctrl+s` (Windows/Linux) or :kbd:`command+s` (mac)) a few times in the :ref:`editor<2 editors>` to run the tests and the terminal_ shows :ref:`AssertionError` with random values that look like this

  the terminal_ shows :ref:`AssertionError`

  .. code-block:: shell

    AssertionError: None != X

  where ``X`` is a random number.

  ``subtract`` returns :ref:`None`, the test expects ``random_first_number-random_second_number`` or ``first_input-second_input`` - the difference between the 2 numbers

* I make the ``subtract`` :ref:`function<functions>` return the difference between the inputs

  .. code-block:: python
    :lineno-start: 5
    :emphasize-lines: 2

    def subtract(first_input, second_input):
        return first_input - second_input

  the test passes. SUCCESS!

=================================================================================
:yellow:`REFACTOR`: make it better
=================================================================================

* I have some duplication to remove, the code below happens twice

  .. code-block:: python

    random_first_number = a_random_number()
    random_second_number = a_random_number()

  once in ``test_addition`` and again ``test_subtraction``. I add :ref:`class attributes (variables)<test_attribute_error_w_class_attributes>` to remove the duplication and use the same numbers for both tests in ``test_calculator.py``

  .. code-block:: python
    :lineno-start: 10
    :emphasize-lines: 3-4

    class TestCalculator(unittest.TestCase):

        random_first_number = a_random_number()
        random_second_number = a_random_number()

        def test_addition(self):

  I use the new :ref:`class attributes<test_attribute_error_w_class_attributes>` in ``test_addition``

  .. code-block:: python
    :lineno-start: 15
    :emphasize-lines: 3, 5

        def test_addition(self):
            # random_first_number = a_random_number()
            random_first_number = self.random_first_number
            # random_second_number = a_random_number()
            random_second_number = self.random_second_number

            self.assertEqual(
                src.calculator.add(random_first_number, random_second_number),
                random_first_number+random_second_number
            )

  and in ``test_subtraction``

  .. code-block:: python
    :lineno-start: 26
    :emphasize-lines: 3, 5

        def test_subtraction(self):
            # random_first_number = a_random_number()
            random_first_number = self.random_first_number
            # random_second_number = a_random_number()
            random_second_number = self.random_second_number

            self.assertEqual(
                src.calculator.subtract(random_first_number, random_second_number),
                random_first_number-random_second_number
            )

  the terminal_ shows the tests are still passing. The ``first_input`` and ``second_input`` :ref:`variables<what is a variable?>` are made once as :ref:`class attributes (variables)<test_attribute_error_w_class_attributes>` (variables) and used later in each test with ``self.random_first_number`` and ``self.random_second_number``, the same way I use `unittest.TestCase`_ :ref:`methods<functions>` like assertEqual_ or assertFalse_

* I remove the commented lines in ``test_addition``

  .. code-block:: python
    :lineno-start: 15

        def test_addition(self):
            x = self.random_first_number
            y = self.random_second_number

  and do the same thing in ``test_subtraction``

  .. code-block:: python
    :lineno-start: 24

        def test_subtraction(self):
            x = self.random_first_number
            y = self.random_second_number

* I can use the :ref:`class attributes<test_attribute_error_w_class_attributes>` directly in ``test_addition``

  .. code-block:: python
    :lineno-start: 19
    :emphasize-lines: 2-3

            self.assertEqual(
                src.calculator.add(self.random_first_number, self.random_second_number),
                self.random_first_number+self.random_second_number
            )

  the test is still green

* I do the same thing in ``test_subtraction``

  .. code-block:: python
    :lineno-start: 28
    :emphasize-lines: 2-3

            self.assertEqual(
                src.calculator.subtract(self.random_first_number, self.random_second_number),
                self.random_first_number-self.random_second_number
            )

* I remove the ``first_input`` and ``second_input`` :ref:`variables<what is a variable?>` from ``test_addition`` and ``test_subtraction`` since they are no longer needed

  .. code-block:: python
    :lineno-start: 10

    class TestCalculator(unittest.TestCase):

        random_first_number = a_random_number()
        random_second_number = a_random_number()

        def test_addition(self):
            self.assertEqual(
                src.calculator.add(self.random_first_number, self.random_second_number),
                self.random_first_number+self.random_second_number
            )

        def test_subtraction(self):
            self.assertEqual(
                src.calculator.subtract(self.random_first_number, self.random_second_number),
                self.random_first_number-self.random_second_number
            )


    # TODO

  and the tests are still green!

* I remove ``test subtraction`` from the TODO list

  .. code-block:: python
    :lineno-start: 28

    # TODO
    # test multiplication
    # test division


    # Exceptions seen

----

*********************************************************************************
test_multiplication
*********************************************************************************

=================================================================================
:red:`RED`: make it fail
=================================================================================

I add a failing test for multiplication in ``test_calculator.py``

.. code-block:: python
  :lineno-start: 21
  :emphasize-lines: 7-11

      def test_subtraction(self):
          self.assertEqual(
              src.calculator.subtract(self.random_first_number, self.random_second_number),
              self.random_first_number-self.random_second_number
          )

      def test_multiplication(self):
          self.assertEqual(
              src.calculator.multiply(self.random_first_number, self.random_second_number),
              self.random_first_number*self.random_second_number
          )

  # TODO

the terminal_ shows :ref:`AttributeError`

.. code-block:: shell

  AttributeError: module 'src.calculator' has no attribute 'multiply'

=================================================================================
:green:`GREEN`: make it pass
=================================================================================

using what I know so far, I add a :ref:`function<functions>` to ``calculator.py``

.. code-block:: python
  :lineno-start: 5
  :emphasize-lines: 5-6

  def subtract(first_input, second_input):
      return first_input - second_input


  def multiply(first_input, second_input):
      return first_input * second_input

the test passes! I remove ``test_multiplication`` from the TODO list in ``test_calculator.py``

.. code-block:: python
  :lineno-start: 34


  # TODO
  # test division


  # Exceptions seen

----

*********************************************************************************
test_division
*********************************************************************************

=================================================================================
:red:`RED`: make it fail
=================================================================================

time for division. I add a new test to ``test_calculator.py``

.. code-block:: python
  :lineno-start: 27
  :emphasize-lines: 7-11

      def test_multiplication(self):
          self.assertEqual(
              src.calculator.multiply(self.random_first_number, self.random_second_number),
              self.random_first_number*self.random_second_number
          )

      def test_division(self):
          self.assertEqual(
              src.calculator.divide(self.random_first_number, self.random_second_number),
              self.random_first_number/self.random_second_number
          )

  # TODO

the terminal_ shows :ref:`AttributeError`

.. code-block:: shell

  AttributeError: module 'src.calculator' has no attribute 'divide'

=================================================================================
:green:`GREEN`: make it pass
=================================================================================

* I add a :ref:`function<functions>` to ``calculator.py``

  .. code-block:: python
    :lineno-start: 9
    :emphasize-lines: 5-6

    def multiply(first_input, second_input):
        return first_input * second_input


    def divide(first_input, second_input):
        return first_input / second_input

  then I make the range of numbers for the tests smaller in ``test_calculator.py``

  .. code-block:: python
    :lineno-start: 6
    :emphasize-lines: 2

    def a_random_number():
        return random.randint(-1, 1)

  I hit save (:kbd:`ctrl+s` (Windows/Linux) or :kbd:`command+s` (mac)) a few times to run the tests, and when ``second_input`` is randomly ``0`` the terminal_ shows :ref:`ZeroDivisionError<test_catching_zero_division_error_in_tests>`

  .. code-block:: python

    x = -1, y = 0
    x = 0, y = 0
    x = 1, y = 0

        def divide(first_input, second_input):
    >       return first_input / second_input
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^
    E       ZeroDivisionError: division by zero

  dividing by ``0`` is undefined in mathematics and raises :ref:`ZeroDivisionError<test_catching_zero_division_error_in_tests>` in Python

* I add it to the list of :ref:`Exceptions<errors>` seen in ``test_calculator.py``

  .. code-block:: python
    :lineno-start: 44
    :emphasize-lines: 6

    # Exceptions seen
    # AssertionError
    # NameError
    # AttributeError
    # TypeError
    # ZeroDivisionError

how to test that ZeroDivisionError is raised
---------------------------------------------------------------------------------

:red:`RED`: make it fail
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

I add a line to cause :ref:`ZeroDivisionError<test_catching_zero_division_error_in_tests>` intentionally and comment out the code that randomly fails in ``test_calculator.py``

.. code-block:: python
  :lineno-start: 33
  :emphasize-lines: 2, 4-7

      def test_division(self):
          src.calculator.divide(self.random_first_number, 0)

          # self.assertEqual(
          #    src.calculator.divide(self.random_first_number, self.random_second_number),
          #    self.random_first_number/self.random_second_number
          # )

the terminal_ shows my expectation with a failure for any value of ``first_input`` since ``second_input`` is ``0``

.. code-block:: python

  x = -1, y = 0
  x = 0, y = 0
  x = 1, y = 0

      def divide(first_input, second_input):
  >       return first_input / second_input
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^
  E       ZeroDivisionError: division by zero

:ref:`Exceptions(Errors)<errors>` like :ref:`ZeroDivisionError<test_catching_zero_division_error_in_tests>` stop a program_ from running. No code runs past the line that causes an :ref:`Exception(Error)<errors>`, which means I have to take care of this problem. See :ref:`how to test that an Exception is raised` for more

:green:`GREEN`: make it pass
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* I can use the `assertRaises method`_ to make sure that :ref:`ZeroDivisionError<test_catching_zero_division_error_in_tests>` is raised when I try to divide a number by ``0``

  .. code-block:: python
    :lineno-start: 33
    :emphasize-lines: 2-3

        def test_division(self):
            with self.assertRaises(AssertionError):
                src.calculator.divide(self.random_first_number, 0)

            # self.assertEqual(
            #   src.calculator.divide(self.random_first_number, self.random_second_number),
            #   self.random_first_number/self.random_second_number
            # )

  because I used the wrong :ref:`Exception<errors>` the terminal_ still shows :ref:`ZeroDivisionError<test_catching_zero_division_error_in_tests>`

  .. code-block:: python

    ZeroDivisionError: division by zero

* I change it to the right :ref:`Exception<errors>`

  .. code-block:: python
    :lineno-start: 33
    :emphasize-lines: 2

        def test_division(self):
            with self.assertRaises(ZeroDivisionError):
                src.calculator.divide(self.random_first_number, 0)

  the test passes, showing that ``src.calculator.divide(self.random_first_number, 0)`` raises :ref:`ZeroDivisionError<test_catching_zero_division_error_in_tests>`

:yellow:`REFACTOR`: make it better
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* I still have a problem because ``self.random_second_number`` can sometimes be ``0``, I use a `while statement`_ to make a never ending loop to make sure it never happens in the :ref:`assertion<what is an assertion?>` in ``test_calculator.py``

  .. code-block:: python
    :lineno-start: 33
    :emphasize-lines: 5-11

        def test_division(self):
            with self.assertRaises(ZeroDivisionError):
                src.calculator.divide(self.random_first_number, 0)

            while self.random_second_number == 0:
                self.random_second_number = a_random_number()
            else:
                self.assertEqual(
                    src.calculator.divide(self.random_first_number, self.random_second_number),
                    self.random_first_number/self.random_second_number
                )

  here is what it does

  - when the value of ``self.random_second_number`` is ``0``

    * it points ``self.random_second_number`` to the result of calling ``a_random_number()``
    * then it checks if the value of ``self.random_second_number`` is ``0`` again. The process happens again non stop until ``self.random_second_number`` is not ``0``

  - when the value of ``self.random_second_number`` is not ``0``, it leaves the while_ loop and runs the code in the ``else`` block

* Since ``self.random_second_number`` is ``0`` in the first part of the `while statement`_ I can add a call that fails to the ``divide`` :ref:`function<functions>`

  .. code-block:: python
    :lineno-start: 33
    :emphasize-lines: 6

        def test_division(self):
            with self.assertRaises(ZeroDivisionError):
                src.calculator.divide(self.random_first_number, 0)

            while self.random_second_number == 0:
                src.calculator.divide(self.random_first_number, self.random_second_number)
                self.random_second_number = a_random_number()
            else:
                self.assertEqual(
                    src.calculator.divide(self.random_first_number, self.random_second_number),
                    self.random_first_number/self.random_second_number
                )

  I hit save (:kbd:`ctrl+s` (Windows/Linux) or :kbd:`command+s` (mac)) in the :ref:`editor<2 editors>` a few times to run the tests, and when ``self.random_second_number`` is randomly ``0``, the terminal_ shows :ref:`ZeroDivisionError<test_catching_zero_division_error_in_tests>`

  .. code-block:: python

    ZeroDivisionError: division by zero

* I add assertRaises_ to catch the :ref:`Exception<errors>` in the `while statement`_

  .. code-block:: python
    :lineno-start: 33
    :emphasize-lines: 6-7

        def test_division(self):
            with self.assertRaises(ZeroDivisionError):
                src.calculator.divide(self.random_first_number, 0)

            while self.random_second_number == 0:
                with self.assertRaises(ZeroDivisionError):
                      src.calculator.divide(self.random_first_number, self.random_second_number)
                self.random_second_number = a_random_number()
            else:
                self.assertEqual(
                    src.calculator.divide(self.random_first_number, self.random_second_number),
                    self.random_first_number/self.random_second_number
                )

* I no longer need the first assertRaises_ and remove it from the test because it is now part of the while_ loop

  .. code-block:: python
    :lineno-start: 33

        def test_division(self):
            while self.random_second_number == 0:
                with self.assertRaises(ZeroDivisionError):
                    src.calculator.divide(self.random_first_number, self.random_second_number)
                self.random_second_number = a_random_number()
            else:
                self.assertEqual(
                    src.calculator.divide(self.random_first_number, self.random_second_number),
                    self.random_first_number/self.random_second_number
                )


    # TODO

  the terminal_ shows all tests are passing with no random failures

* I use a bigger range of numbers for the tests

  .. code-block:: python
    :lineno-start: 6
    :emphasize-lines: 2

    def a_random_number():
        return random.randint(-10**1000000, 10**1000000)

  the terminal_ still shows green and it takes longer to run the tests. I change the range back to ``-10, 10`` to keep the tests fast

  .. code-block:: python
    :lineno-start: 6
    :emphasize-lines: 2

    def a_random_number():
        return random.randint(-10, 10)

* then I remove the TODO list

  .. code-block:: python
    :lineno-start: 45

    # Exceptions seen
    # AssertionError
    # NameError
    # AttributeError
    # TypeError
    # ZeroDivisionError

----

*********************************************************************************
test_calculator_tests
*********************************************************************************

Since everything is green, I can write the program_ that makes the tests pass without looking at them

=================================================================================
:red:`RED`: make it fail
=================================================================================

* I close ``test_calculator.py``
* then delete all the text in ``calculator.py``, the terminal_ shows 4 failures, I start with the last :ref:`AttributeError`

  .. code-block:: shell

    AttributeError: module 'src.calculator' has no attribute 'subtract'

  What :ref:`Exceptions<errors>` do you think are raised as I go along?

=================================================================================
:green:`GREEN`: make it pass
=================================================================================

* I add the name to ``calculator.py``

  .. code-block:: python
    :linenos:
    :emphasize-lines: 1

    subtract

  the terminal_ shows :ref:`NameError<test_catching_name_error_in_tests>`

  .. code-block:: shell

    NameError: name 'subtract' is not defined

  I point it to :ref:`None`

  .. code-block:: python
    :linenos:
    :emphasize-lines: 1

    subtract = None

  the terminal_ shows :ref:`TypeError`

  .. code-block:: shell

    TypeError: 'NoneType' object is not callable

  I change ``subtract`` to a :ref:`function<functions>`

  .. code-block:: python
    :linenos:
    :emphasize-lines: 1-2

    def subtract():
        return None

  the terminal_ shows :ref:`TypeError`

  .. code-block:: shell

    TypeError: subtract() takes 0 positional arguments but 2 were given

  I add :ref:`positional arguments<test_functions_w_positional_arguments>` to the :ref:`function<functions>`

  .. code-block:: python
    :linenos:
    :emphasize-lines: 1

    def subtract(first_input, second_input):
        return None

  the terminal_ shows :ref:`AssertionError`

  .. code-block:: shell

    AssertionError: None != X

* I change the `return statement`_ to see the difference between the inputs and expected output

  .. code-block:: python
    :linenos:
    :emphasize-lines: 2

    def subtract(first_input, second_input):
        return first_input, second_input

  the terminal_ shows random numbers with :ref:`AssertionError` that look like this

  .. code-block:: shell

    AssertionError: (X, Y) != Z

  the name of the :ref:`function<functions>` is ``subtract`` and the test expects the difference between the 2 inputs

* I make the `return statement`_ match the expectation

  .. code-block:: python
    :linenos:
    :emphasize-lines: 2

    def subtract(first_input, second_input):
        return first_input - second_input

  the terminal_ shows :ref:`AttributeError`

  .. code-block:: shell

    AttributeError: module 'src.calculator' has no attribute 'multiply'

* I add a :ref:`function<functions>`

  .. code-block:: python
    :linenos:
    :emphasize-lines: 5-6

    def subtract(first_input, second_input):
        return first_input - second_input


    def multiply():
        return None

  the terminal_ shows :ref:`TypeError`

  .. code-block:: shell

    TypeError: multiply() takes 0 positional arguments but 2 were given

  I add 2 :ref:`variables<what is a variable?>` for the positional arguments

  .. code-block:: python
    :lineno-start: 5
    :emphasize-lines: 1

    def multiply(first_input, second_input):
        return None

  the terminal_ shows :ref:`AssertionError`

  .. code-block:: shell

    AssertionError: None != X

* I change the `return statement`_ to see the difference between the inputs and the expected output

  .. code-block:: python
    :lineno-start: 5
    :emphasize-lines: 2

    def multiply(first_input, second_input):
        return first_input, second_input

  the terminal_ shows random numbers with :ref:`AssertionError` that look like this

  .. code-block:: shell

    AssertionError: (X, Y) != Z

  I change it to the multiplication of the inputs to match the name of the :ref:`function<functions>`

  .. code-block:: python
    :lineno-start: 5
    :emphasize-lines: 2

    def multiply(first_input, second_input):
        return first_input * second_input

  the terminal_ shows :ref:`AttributeError`

  .. code-block:: shell

    AttributeError: module 'src.calculator' has no attribute 'divide'

* I add another :ref:`function<functions>`

  .. code-block:: python
    :lineno-start: 5
    :emphasize-lines: 5-6

    def multiply(first_input, second_input):
        return first_input * second_input


    def divide(first_input, second_input):
        return first_input, second_input

  the terminal_ shows :ref:`AssertionError` with random numbers that look like this

  .. code-block:: shell

    AssertionError: (-10, 6) != -1.6666666666666667
    AssertionError: (-6, -6) != 1.0
    AssertionError: (5, 7) != 0.7142857142857143
    AssertionError: (10, 9) != 1.1111111111111112

  or

  .. code-block:: shell

    AssertionError: ZeroDivisionError not raised

  when I change the `return statement`_ to match the expectation

  .. code-block:: python
    :lineno-start: 9
    :emphasize-lines: 2

    def divide(first_input, second_input):
        return first_input / second_input

  the terminal_ shows :ref:`AttributeError`

  .. code-block:: shell

    AttributeError: module 'src.calculator' has no attribute 'add'

* the `return statement`_ of the last 3 :ref:`functions` matched their names, I do the same thing for the new one

  .. code-block:: python
    :linenos:
    :emphasize-lines: 13-14

    def subtract(first_input, second_input):
        return first_input - second_input


    def multiply(first_input, second_input):
        return first_input * second_input


    def divide(first_input, second_input):
        return first_input / second_input


    def add(first_input, second_input):
        return first_input + second_input

  and all the tests are passing with no random failures. Lovely! I am a Programmer!

----

*********************************************************************************
close the project
*********************************************************************************

* I close the file(s) I have open in the :ref:`editor(s)<2 editors>`
* I click in the terminal_ and exit the tests with :kbd:`ctrl+c` on the keyboard
* I deactivate the `virtual environment`_

  .. code-block:: shell
    :emphasize-lines: 1

    deactivate

  the terminal_ goes back to the command line, ``(.venv)`` is no longer on the left side

  .. code-block:: shell

    .../pumping_python/calculator

* I `change directory`_ to the parent of ``calculator``

  .. code-block:: shell
    :emphasize-lines: 1

    cd ..

  the terminal_ shows

  .. code-block:: shell

    .../pumping_python

  I am back in the ``pumping_python`` directory_

----

*********************************************************************************
review
*********************************************************************************

I wrote the following tests for a program_ that can :ref:`add<test_addition>`, :ref:`subtract<test_subtraction>`, :ref:`multiply<test_multiplication>` and :ref:`divide<test_division>`

* `test_addition`_
* `test_subtraction`_
* `test_multiplication`_
* `test_division`_

I also saw the following :ref:`Exceptions<errors>`

* :ref:`AssertionError`
* :ref:`NameError<test_catching_name_error_in_tests>`
* :ref:`AttributeError`
* :ref:`TypeError`
* :ref:`ZeroDivisionError<test_catching_zero_division_error_in_tests>`

----

*************************************************************************************
code from the chapter
*************************************************************************************

:ref:`Do you want to see all the CODE I typed in this chapter?<how to make a calculator: tests and solutions>`

----

*********************************************************************************
what is next?
*********************************************************************************

you know a lot

* :ref:`how to make a test driven development environment`
* :ref:`how to raise AssertionError with assert methods<AssertionError>`
* :ref:`how to write functions<functions>`
* :ref:`how to pass values from tests to functions<how to pass values>`
* :ref:`what is None and NOT None<None>`
* :ref:`what is True and False in Python<booleans>`
* :ref:`how to write programs that make decisions<booleans: truth table>`
* :ref:`how to make a calculator`

There is a problem, I have done the same steps for each of the 8 chapters covered so far

* I give the project a name
* :ref:`I make a directory for the project<how to make a directory for the project>`
* :ref:`I change directory to the project<how to change directory to the project>`
* :ref:`I make a directory for the source code named 'src'<how to make a directory for the source code>`
* :ref:`I make a Python file to hold the source code in the 'src' folder<how to make an empty file>`
* :ref:`I make a directory for the tests<how to make a directory for the tests>`
* :ref:`I make the 'tests' folder a Python package<how to make the tests a Python package>`
* :ref:`I make a Python file to hold the tests in the 'tests' folder<test_failure>`
* :ref:`I add the first failing test to the test file<test_failure>`
* :ref:`I make a virtual environment<how to make a virtual environment>`
* :ref:`I activate the virtual environment<how to activate a virtual environment>`
* :ref:`I upgrade the Python package manager<how to upgrade the Python package manager in a virtual environment>`
* :ref:`I make a requirements file for the needed Python packages<how to write text to a file>`
* :ref:`I install the packages listed in the requirements file<how to install Python packages in a virtual environment>`
* :ref:`I run the tests automatically<how to run the tests automatically in a virtual environment>`
* :ref:`I open the test file in the editor from the terminal<how to open the test file in the editor from the terminal>`
* I make the test pass
* then I start working on the project

I think I know how to make a Python_ :ref:`Test Driven Development environment<what is a Test Driven Development Environment?>`. I am going to :ref:`write a program that will do all the steps for making a project for me<how to make a Python Test Driven Development environment automatically>`, so I never have to do those steps again.

Would you like to know how to make a Python Test Driven Development environment automatically on a computer with

* :ref:`MacOS, Linux or Windows with Subsystem for Linux?<how to make a Python Test Driven Development environment automatically>` or
* :ref:`Windows without Windows Subsystem Linux?<how to make a Python Test Driven Development environment automatically on Windows without Windows Subsystem for Linux>`

-----


.. raw:: html

  <!-- TrustBox widget - Review Collector -->
  <div class="trustpilot-widget" data-locale="en-US" data-template-id="56278e9abfbbba0bdcd568bc" data-businessunit-id="69141d0f0902d6a2a1b2436b" data-style-height="52px" data-style-width="100%" data-token="5db17dde-bcdc-460f-81f3-d8ab689b6e4d">
    <a href="https://www.trustpilot.com/review/pumpingpython.com" target="_blank" rel="noopener">CLICK HERE to leave a 5 star review, if this has been a 7 star experience for you</a>
  </div>
  <!-- End TrustBox widget -->